<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">

  
  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <title>python的性能问题</title>

  
  
  <link rel="stylesheet" href="https://shell909090.github.io/css/hugo-octopress.css">

  
  

  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  
  <link href="https://shell909090.github.io/favicon.png" rel="icon">

  
  
  

  

  <meta name="description" content="">
  <meta name="keywords" content="">

  <meta name="author" content="">

  
  <meta name="generator" content="Hugo 0.17-DEV" />

  
  

</head>
<body>


<header role="banner"><hgroup>
  
  <h1><a href="https://shell909090.github.io/">Shell&#39;s Home</a></h1>
    <h2></h2>
</hgroup></header>


<nav role="navigation">

<ul class="main-navigation">
  
  
</ul>


<ul class="subscription">
  

  
  

</ul>


</nav>


<div id="main">
  <div id="content">
    <div>
      <article class="hentry" role="article">

        
        

<header>
    <h1 class="entry-title">
         python的性能问题 
    </h1>
    <p class="meta">Aug 27, 2008
         - 4 minute read 
         - <a href="https://shell909090.github.io/blog/archives/31/#disqus_thread">Comments</a>

        
    </p>
</header>


        <div class="entry-content">
          
          
          
          <p>贝壳最近在一个朋友的网站上看到了关于SICP零钱兑换问题的python求解，使用了记忆机制，然后他给出了代码。然而他的代码计时上有点小问题，也没有用包装器(奇怪的是，有写)，而且python的栈深度有限。因此贝壳做了几个修改的版本，需要测试下性能，下面就是关于性能的几个问题和过程。
本文详细论述了python语言下和C++语言下使用各种方法测试代码性能的方法，以及粗略的关于两种语言不同算法性能对比。
原始的python代码是这样的：
def change_coins(money):
first_denomination = {
1:1,  2:5,
3:10, 4:25,
5:50,
}
def cc((amount, kinds_of_coins)):
if amount == 0:
return 1
elif amount &lt; 0 or kinds_of_coins == 0:
return 0
else:
return     cc((amount, kinds_of_coins - 1))
+ cc((amount - first_denomination[kinds_of_coins], kinds_of_coins))
print &ldquo;change_coins return %s&rdquo; % cc((money, 5));
return ;
利用记忆原理包装后是这样的：
def memoiza(fun):
cache = {}
def proc ( *arg ):
if cache.has_key(arg):
return cache[arg]
else:
x = fun( *arg )
cache[arg] = x
return x
return proc</p>

<p>def decorator_change_coins(money):
first_denomination = {
1:1,  2:5,
3:10, 4:25,
5:50,
}
@memoiza
def cc(amount, kinds_of_coins):
if amount == 0:
return 1
elif amount &lt; 0 or kinds_of_coins == 0:
return 0
else:
return cc(amount, kinds_of_coins - 1)
+ cc(amount - first_denomination[kinds_of_coins], kinds_of_coins)
print &ldquo;decorator_change_coins return %s&rdquo; % cc(money, 5);
return ;
不记忆，利用栈模拟递归展开是这样的：
def native_change_coins(money):
first_denomination = {
1:1,  2:5,
3:10, 4:25,
5:50,
}
stack = [(money, 5)];
rslt = 0;
while len (stack) &gt; 0:
param = stack.pop ();
if param[0] == 0:
rslt += 1;
continue;
elif param[0] &lt; 0 or param[1] == 0:
continue;
else:
stack.append ((param[0], param[1] - 1));
stack.append ((param[0] - first_denomination[param[1]], param[1]));
continue;
print &ldquo;native_change_coins return %s&rdquo; % rslt;
return ;</p>

<p>贝壳主要需要测试上面三个代码的执行效率和瓶颈，所以贝壳用的主代码是这样的：
import time
import timeit
import profile</p>

<p>def test_func(f):
f (300);</p>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&ldquo;:
t = timeit.Timer(&ldquo;test_func (change_coins)&ldquo;, &ldquo;from <strong>main</strong> import *&ldquo;);
print min(t.repeat (5, 1));</p>

<p>t = timeit.Timer(&ldquo;test_func (decorator_change_coins)&ldquo;, &ldquo;from <strong>main</strong> import *&ldquo;);
print min(t.repeat (5, 1));</p>

<p>t = timeit.Timer(&ldquo;test_func (native_change_coins)&ldquo;, &ldquo;from <strong>main</strong> import *&ldquo;);
print min(t.repeat (5, 1));</p>

<p>profile.run(&ldquo;test_func (change_coins)&ldquo;);
profile.run(&ldquo;test_func (decorator_change_coins)&ldquo;);
profile.run(&ldquo;test_func (native_change_coins)&ldquo;);</p>

<p>下面是部分结果：
change_coins return 9590
1.22809910198
decorator_change_coins return 9590
0.00217178440277
native_change_coins return 9590
2.69215193551</p>

<p>以上是时间测试结果，使用timeit模块来测试运行时间，重复5次，取最小值。具体原理可以看dive into python，详细请看上面的代码。从结果中我们可以看到，使用记忆技术后，性能提升了500多倍，这是符合规律的。然而使用了集合模拟栈之后，性能大幅下降。下面我们看看为什么。</p>

<p>change_coins return 9590
1292596 function calls (6 primitive calls) in 13.591 CPU seconds</p>

<p>Ordered by: standard name</p>

<p>ncalls  tottime  percall  cumtime  percall filename:lineno(function)
1    0.059    0.059    0.059    0.059 :0(setprofile)
1    0.000    0.000   13.533   13.533 :1()
1    0.000    0.000   13.533   13.533 amount.py:102(test_func)
<sup>1292591</sup>&frasl;<sub>1</sub>   13.531    0.000   13.531   13.531 amount.py:11(cc)
1    0.001    0.001   13.533   13.533 amount.py:5(change_coins)
0    0.000             0.000          profile:0(profiler)
1    0.000    0.000   13.591   13.591 profile:0(test_func (change_coins))</p>

<p>decorator_change_coins return 9590
2494 function calls (881 primitive calls) in 0.027 CPU seconds</p>

<p>Ordered by: standard name</p>

<p>ncalls  tottime  percall  cumtime  percall filename:lineno(function)
873    0.004    0.000    0.004    0.000 :0(has_key)
1    0.000    0.000    0.000    0.000 :0(setprofile)
1    0.000    0.000    0.027    0.027 :1()
1    0.000    0.000    0.027    0.027 amount.py:102(test_func)
1    0.000    0.000    0.000    0.000 amount.py:51(memoiza)
<sup>873</sup>&frasl;<sub>1</sub>    0.013    0.000    0.026    0.026 amount.py:53(proc)
1    0.001    0.001    0.027    0.027 amount.py:62(decorator_change_coins)
<sup>742</sup>&frasl;<sub>1</sub>    0.009    0.000    0.026    0.026 amount.py:68(cc)
0    0.000             0.000          profile:0(profiler)
1    0.000    0.000    0.027    0.027 profile:0(test_func (decorator_change_coins))</p>

<p>native_change_coins return 9590
3877778 function calls in 38.798 CPU seconds</p>

<p>Ordered by: standard name</p>

<p>ncalls  tottime  percall  cumtime  percall filename:lineno(function)
1292590    5.824    0.000    5.824    0.000 :0(append)
1292592    5.960    0.000    5.960    0.000 :0(len)
1292591    6.076    0.000    6.076    0.000 :0(pop)
1    0.000    0.000    0.000    0.000 :0(setprofile)
1    0.000    0.000   38.798   38.798 :1()
1    0.000    0.000   38.798   38.798 amount.py:102(test_func)
1   20.938   20.938   38.798   38.798 amount.py:80(native_change_coins)
0    0.000             0.000          profile:0(profiler)
1    0.000    0.000   38.798   38.798 profile:0(test_func (native_change_coins))
以上是白盒分析结果，使用profile测试，主要分析函数的调用花费。具体可以参考<a href="http://www.sqlite.com.cn">http://www.sqlite.com.cn</a> /MySqlite/11/480.Html。从上面的报表中，我们可以看出，最初的函数执行时间全消耗在了cc上。而记忆后，则是proc和cc基本对半，有的时候has_key测试也花点时间。这表示cc花费的时间大幅下降，记忆技术则花了比较多的时间。而模拟的呢？大部分时间都花在了 append,len,pop这三个函数上！这说明原始集合的效率严重制约了模拟效率。如果要提升性能的话，使用其他的集合吧。
另外贝壳又用C++写了一个，如下：</p>

<p>const int coin_map[] = {
1, 5, 10, 25, 50
};
const int coin_count = 5;</p>

<p>int cc (int amount, int kind_of_coins)
{
if (amount == 0)
return 1;
if (amount &lt; 0 || kind_of_coins &lt;= 0)
return 0;
return cc (amount, kind_of_coins - 1) + cc (amount - coin_map[kind_of_coins - 1], kind_of_coins);
}</p>

<p>int dd (int amount, int kind_of_coins)
{
if (amount == 0)
return 1;
if (amount &lt; 0 || kind_of_coins &lt;= 0)
return 0;
int rslt = 0;
for (int i = 0; i &lt;= amount / coin_map[kind_of_coins - 1]; ++i)
rslt += dd (amount - i * coin_map[kind_of_coins - 1], kind_of_coins - 1);
return rslt;
}</p>

<p>class keys{
public:
int amount;
int kind_of_coins;
keys (int amount_p, int kind_of_coins_p):
amount(amount_p), kind_of_coins(kind_of_coins_p)
{}
bool operator == (const keys &amp; k) const{
return (amount == k.amount &amp;&amp; kind_of_coins == k.kind_of_coins);
}
bool operator &lt; (const keys &amp; k) const{
if (kind_of_coins == k.kind_of_coins)
return amount &lt; k.amount;
return kind_of_coins &lt; k.kind_of_coins;
}
};</p>

<p>map mCache;</p>

<p>int ee (int amount, int kind_of_coins)
{
if (amount == 0)
return 1;
if (amount &lt; 0 || kind_of_coins &lt;= 0)
return 0;
keys k (amount, kind_of_coins);
map::iterator iter = mCache.find(k);
if (iter != mCache.end ())
return iter-&gt;second;
int rslt = 0;
for (int i = 0; i &lt;= amount / coin_map[kind_of_coins - 1]; ++i)
rslt += dd (amount - i * coin_map[kind_of_coins - 1], kind_of_coins - 1);
mCache.insert(pair(k, rslt));
return rslt;
}</p>

<p>int _tmain(int argc, _TCHAR* argv[])
{
const int loop_times = 300;
clock_t s = clock();
printf (&ldquo;kind of coins: %dn&rdquo;, cc (loop_times, coin_count));
printf (&ldquo;times:%dn&rdquo;, clock () - s);</p>

<p>s = clock();
printf (&ldquo;kind of coins: %dn&rdquo;, dd (loop_times, coin_count));
printf (&ldquo;times:%dn&rdquo;, clock () - s);</p>

<p>s = clock();
printf (&ldquo;kind of coins: %dn&rdquo;, ee (loop_times, coin_count));
printf (&ldquo;times:%dn&rdquo;, clock () - s);
return 0;
}
注意到主函数中，使用的是clock来计量时间。如果C++下要做白盒性能测试就比较麻烦，需要用精确计时函数和宏。需要的可以单独和我联系。下面是部分计算结果，cc的和ee的，没有dd的。
300的计算结果
kind of coins: 9590
times:62
kind of coins: 9590
times:46
1000的计算结果
kind of coins: 801451
times:15953
kind of coins: 801451
times:11000
单位，ms。
原生的效率差异是20倍，用了缓存后性能只有略略上升？！反而是python比较快？
看来C++下的map效率也不高，要用hash_map才好。
倒是栈长度好很多，贝壳估计是131072次调用，大约是16384分。</p>

        </div>
        

<footer>
  <p class="meta">
    <span class="byline author vcard">Posted by <span class="fn"></span></span>
    
    <time>Aug 27, 2008</time>
    <span class="categories">
      Tags:
        
        
          <a class="category" href="https://shell909090.github.io/tags/c">c</a>  <a class="category" href="https://shell909090.github.io/tags/performance">performance</a>  <a class="category" href="https://shell909090.github.io/tags/program">program</a>  <a class="category" href="https://shell909090.github.io/tags/python">python</a>  
        
    </span>
  </p>

  
  

  

  <p class="meta">
    
        <a class="basic-alignment left" href="https://shell909090.github.io/blog/archives/30/" title="运气真好">运气真好</a>
    

    
      <a class="basic-alignment right" href="https://shell909090.github.io/blog/archives/32/" title="C&#43;&#43;下的Variant">C&#43;&#43;下的Variant</a>
    
  </p>
  
    
      <div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    
    

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'shell909090blog';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
  
</footer>

      </article>
    </div>
    

<aside class="sidebar thirds">
  <section class="first odd">

    

    <p>
      
    </p>
  </section>



  
  <ul class="sidebar-nav">
    <li class="sidebar-nav-item">
      
      
      
       
      
      
      
      
      

    
    
    </li>
  </ul>

  

  

  
  
  
    <section class="even">
      <h1>Recent Posts</h1>
      <ul id="recent_posts">
        
          <li class="post">
            <a href="/blog/archives/2835/">唐僧被吃了</a>
          </li>
        
          <li class="post">
            <a href="/blog/archives/2832/">三亚潜水体验</a>
          </li>
        
          <li class="post">
            <a href="/blog/archives/2829/">潜水的一些简单解说</a>
          </li>
        
          <li class="post">
            <a href="/blog/archives/2822/">一个有趣的问题</a>
          </li>
        
          <li class="post">
            <a href="/blog/archives/2820/">一次升级故障的排查</a>
          </li>
        
          <li class="post">
            <a href="/blog/archives/2816/">关于程序员和产品经理两大世界体系的对话——论快播庭审</a>
          </li>
        
          <li class="post">
            <a href="/blog/archives/2813/">云计算的成本计算</a>
          </li>
        
          <li class="post">
            <a href="/blog/archives/2809/">说说密码和安全设计</a>
          </li>
        
          <li class="post">
            <a href="/blog/archives/2806/">从青蒿素得奖说现代医学里的方法论</a>
          </li>
        
          <li class="post">
            <a href="/blog/archives/2804/">印度游记-4</a>
          </li>
        
      </ul>
    </section>
  

</aside>

  </div>
</div>

<footer role="contentinfo">
  <p>Copyright &copy; 2016  - <a href="https://shell909090.github.io/license/">License</a> -
  <span class="credit">Powered by <a target="_blank" href="https://gohugo.io">Hugo</a> and <a target="_blank" href="https://github.com/parsiya/hugo-octopress/">Hugo-Octopress</a> theme.
</p>

</footer>


</body>
</html>

