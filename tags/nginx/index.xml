<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nginx on Shell&#39;s Home</title>
    <link>http://shell909090.org/tags/nginx/</link>
    <description>Recent content in Nginx on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Wed, 15 Jan 2014 10:53:20 +0800</lastBuildDate>
    <atom:link href="http://shell909090.org/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>golang和nginx的简单性能对比</title>
      <link>http://shell909090.org/blog/archives/2536/</link>
      <pubDate>Wed, 15 Jan 2014 10:53:20 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2536/</guid>
      <description>&lt;h1&gt;说明&lt;/h1&gt;

&lt;p&gt;测试都是ab做的，中等并发量，统一采用10000并发，100000个请求。都是本机请求本机，避免公司内网IDS的干扰。&lt;/p&gt;

&lt;p&gt;机器是一台双核CPU的DELL：Intel(R) Pentium(R) CPU G2030 @ 3.00GHz。配4G内存。&lt;/p&gt;

&lt;p&gt;第一组数据是ab测试nginx，nginx的配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;worker_processes 4;
pid /run/nginx.pid;
worker_rlimit_nofile 30000;

events {
        worker_connections 20000;
        multi_accept on;
}

http {
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二组是ab测试golang，返回固定是个OK。&lt;/p&gt;

&lt;p&gt;第三组是ab测试golang，返回某个目录或文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;err := http.ListenAndServe(&#34;:8080&#34;, http.FileServer(http.Dir(&#34;/home/shell/photo&#34;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;nginx&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Concurrency Level:      10000
Time taken for tests:   5.720 seconds
Complete requests:      100000
Failed requests:        0
Write errors:           0
Total transferred:      172100000 bytes
HTML transferred:       160000000 bytes
Requests per second:    17482.47 [#/sec] (mean)
Time per request:       572.001 [ms] (mean)
Time per request:       0.057 [ms] (mean, across all concurrent requests)
Transfer rate:          29382.16 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0  320 581.1    146    3262
Processing:     1  197 136.6    198    1886
Waiting:        1  162 120.6    154    1811
Total:          1  517 604.1    371    3558

Percentage of the requests served within a certain time (ms)
  50%    371
  66%    455
  75%    515
  80%    587
  90%   1167
  95%   1378
  98%   3375
  99%   3402
 100%   3558 (longest request)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;golang with string&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Concurrency Level:      10000
Time taken for tests:   5.147 seconds
Complete requests:      100000
Failed requests:        0
Write errors:           0
Total transferred:      11800000 bytes
HTML transferred:       200000 bytes
Requests per second:    19429.37 [#/sec] (mean)
Time per request:       514.685 [ms] (mean)
Time per request:       0.051 [ms] (mean, across all concurrent requests)
Transfer rate:          2238.93 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0  293 659.6      5    3020
Processing:     1   37 112.3     10    1644
Waiting:        1   34 111.9      9    1642
Total:          3  329 700.4     16    4653

Percentage of the requests served within a certain time (ms)
  50%     16
  66%     25
  75%    248
  80%   1003
  90%   1032
  95%   1431
  98%   3026
  99%   3042
 100%   4653 (longest request)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;golang with file&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Concurrency Level:      10000
Time taken for tests:   8.122 seconds
Complete requests:      100000
Failed requests:        0
Write errors:           0
Keep-Alive requests:    100000
Total transferred:      72200000 bytes
HTML transferred:       53500000 bytes
Requests per second:    12312.87 [#/sec] (mean)
Time per request:       812.158 [ms] (mean)
Time per request:       0.081 [ms] (mean, across all concurrent requests)
Transfer rate:          8681.54 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0   29 333.4      0    7009
Processing:     0  495  98.1    524    1918
Waiting:        0  495  98.1    524    1918
Total:          0  524 353.0    525    8086

Percentage of the requests served within a certain time (ms)
  50%    525
  66%    531
  75%    535
  80%    537
  90%    543
  95%    550
  98%    558
  99%    563
 100%   8086 (longest request)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;分析&lt;/h1&gt;

&lt;p&gt;从rps来看，三者都达到了10Krps的级别以上，而且差距很小。golang在没有逻辑的情况下比nginx还要快11%，但是加入逻辑后反而落后30%（这不奇怪）。三者差距都在50%以内，基本属于同一个数量级。&lt;/p&gt;

&lt;p&gt;如果不考虑golang本身的内存管理问题，我觉得可以用golang替代nginx+lua的方案了。至少代码好写很多。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>debian wheezy下以uwsgi安装graphite</title>
      <link>http://shell909090.org/blog/archives/2200/</link>
      <pubDate>Mon, 09 Jul 2012 08:45:28 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2200/</guid>
      <description>&lt;div&gt;# abstract #&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;graphite是一个python写的性能监控系统。这个系统是由多个分离的部分组成的。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* graphite-web: 由django写的web界面系统。&lt;/div&gt;&lt;div&gt;* carbon: 数据收集的守护进程。&lt;/div&gt;&lt;div&gt;* whisper: 一种python写的数据库，类似rrd，便于大量的性能日志数据收集和处理。上两个组件会调用这个库。&lt;/div&gt;

&lt;div&gt;* collectd: 数据收集守护进程，向carbon中喂数据的数据源。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;另外，有一点黑色幽默的就是，graphite的意思是石墨，是炭(carbon)的一种同素异形体。因此在graphite项目中，多次出现carbon这个名字。当然，另两个同素异形体是钻石(diamond)和足球烯(footballene)，你就暂时别指望看到他们的身影了。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;

&lt;div&gt;另一个用python写的，以元素命名的著名软件是mercurial。化学元素中的汞，俗称水银，符号hg。因此mercurial的命令行简写才是hg。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;以上几个的结构大概是这样的：&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;collectd(source) -network-&amp;gt; carbon -writing-&amp;gt; whisper database -reading-&amp;gt; graphite-web&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;下文描述了在debian wheezy下，以nginx+uwsgi模式安装graphite的过程。之所以用这个模式，是因为我的大部分系统都是python写的，同样安装在uwsgi下面。一事不烦二主。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# carbon #&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;carbon有对应的debian包，可以很简单的安装。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;

&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;sudo aptitude install graphite-carbon&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;默认的数据端口是2003，默认的数据路径是/var/lib/graphite/，这个在下文需要用到。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# graphite #&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;## virtual ##&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;graphite有部分需要安装到系统中，因此最好用virtualenv进行安装。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;cd /var/web/&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;sudo aptitude install python-virtualenv&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;virtualenv --system-site-packages graphite&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;我假定你的安装路径是/var/web/graphite，这个在下面要反复用到。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;## install ##&lt;/div&gt;&lt;div&gt;

&lt;br /&gt;&lt;/div&gt;&lt;div&gt;在安装路径下，执行以下内容&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;source bin/activite&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;pip install graphite-web --install-option=&amp;quot;--prefix=/var/web/graphite&amp;quot; --install-option=&amp;quot;--install-lib=/var/web/graphite/webapp&amp;quot;&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;注意，/var/web/graphite需要根据上面的设定自行修改，webapp是你的django基础路径。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;## configure ##&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;在/var/web/graphite/webapp/graphite下面，执行以下内容&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;cp local_settings.py.example local_settings.py&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;然后编辑local_settings.py&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;GRAPHITE_ROOT = &amp;#39;/var/web/graphite&amp;#39;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;WHISPER_DIR = &amp;#39;/var/lib/graphite/whisper&amp;#39;&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;DATABASES = ...&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;注意databases，不要在settings.py里面修改，要改这里的才有效。我用的是sqlite，如果你高兴，可以改为postgres/mysql。WHISPER_DIR是上文carbon中设定的目录。&lt;/div&gt;&lt;div&gt;

&lt;br /&gt;&lt;/div&gt;&lt;div&gt;最后，执行以下指令，完成数据库初始化。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;python manage.py syncdb&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;## uwsgi ##&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;编辑/etc/uwsgi/apps-enabled/graphite.ini，包含以下内容。&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;[uwsgi]&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;plugins         = python&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;workers         = 1&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;chdir           = /var/web/graphite/webapp&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;pythonpath      = /var/web/graphite&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;env             = DJANGO_SETTINGS_MODULE=graphite.settings&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;module          = django.core.handlers.wsgi:WSGIHandler()&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;注意，这里的chdir，是你的webapp基础路径。而pythonpath则是virtualenv的路径。两者在上文都有说明的。env里面那个graphite是webapp/graphite这个app(不详细说明，自己学一下django就懂了)。module是django的固定写法。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;## nginx ##&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt; &lt;div&gt; 最后，在nginx中包含以下内容，将部分url转发到uwsgi上。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;location ~ ^/(graphite|content|metrics|dashboard|render|browser|composer)/ {&lt;/div&gt;&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;include        uwsgi_params;&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;uwsgi_param    UWSGI_SCHEME $scheme;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;     &lt;/span&gt;uwsgi_pass     unix:/run/uwsgi/app/graphite/socket;&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;}&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# collectd #&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;## install ##&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;collectd的安装很简答，有包，直接安装就好。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;sudo aptitude install collectd&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;## configure ##&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;在/etc/collectd/这个路径，能够看到collectd.conf这个文件。反注释掉以下内容：&lt;/div&gt;&lt;div&gt; &lt;br /&gt; &lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;&amp;lt;LoadPlugin python&amp;gt;&lt;/div&gt;&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;Globals true&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;&amp;lt;/LoadPlugin&amp;gt;&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;然后，再编辑以下内容。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;&amp;lt;Plugin python&amp;gt;&lt;/div&gt;&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;ModulePath &amp;quot;/etc/collectd/carbon&amp;quot;&lt;/div&gt;

&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;Import “carbon_writer”&lt;/div&gt;&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;&amp;lt;Module “carbon_writer”&amp;gt;&lt;/div&gt;&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;       &lt;/span&gt;LineReceiverHost “localhost″&lt;/div&gt;

&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;LineReceiverPort 2003&lt;/div&gt;&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;        &lt;/span&gt;DifferentiateCountersOverTime true&lt;/div&gt;&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;       &lt;/span&gt;LowercaseMetricNames true&lt;/div&gt;

&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;TypesDB &amp;quot;/usr/share/collectd/types.db&amp;quot;&lt;/div&gt;&lt;div&gt;    &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;&amp;lt;/Module&amp;gt;&lt;/div&gt;&lt;div&gt;

    &amp;lt;/Plugin&amp;gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;上文中假定你把python插件放在了/etc/collectd/carbon下面，所以下文需要按照这个路径安装carbon。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;## collectd-carbon ##&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;在/etc/collectd下面，执行&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt; &lt;div&gt; &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;sudo git clone &lt;a href=&#34;https://github.com/indygreg/collectd-carbon.git&#34;&gt;https://github.com/indygreg/collectd-carbon.git&lt;/a&gt; carbon&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;注意，sudo其实是不安全的。不过目前就这样吧，问题不明显。&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;## restart whole system ##&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;执行以下指令重启服务&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;sudo /etc/init.d/nginx restart&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;sudo /etc/init.d/uwsgi restart&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;sudo /etc/init.d/carbon-cache restart&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;sudo /etc/init.d/collectd restart&lt;/div&gt;&lt;div&gt;&lt;br /&gt;

&lt;/div&gt;&lt;div&gt;完成这步后，可以在/var/log/syslog中看到collectd的输出，数据确实的被灌入了carbon。而/var/log/uwsgi/app/graphite.log中可以看到uwsgi的输出。如果一切正常的话，你可以去[&lt;a href=&#34;http://localhost/graphite/%5D%28http://localhost/graphite/)%E4%B8%8B%E9%9D%A2%E7%9C%8B%E4%BD%A0%E8%A6%81%E7%9A%84%E4%B8%9C%E8%A5%BF%E4%BA%86&#34;&gt;http://localhost/graphite/](http://localhost/graphite/)下面看你要的东西了&lt;/a&gt;。&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# 评价 #&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;数据收集的挺完整的。既然是基于collectd，那么应当没什么问题的，openwrt也可以支持的。问题是拿到数据后展现的一方面。由于默认配置太差，因此需要很长时间调教。我没那个功夫，搞定测试后就直接删除了。&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>uwsgi under debian</title>
      <link>http://shell909090.org/blog/archives/1919/</link>
      <pubDate>Tue, 27 Sep 2011 10:28:02 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1919/</guid>
      <description>&lt;p&gt;好了，debian官方的uwsgi总算出来了。包已经到了testing，stable暂时别指望了，等下一次release吧。这次打的包，比贝壳打的复杂多了。贝壳自己只打了python专用的包，debian官方的包将多个语言分别打成了plugins。 &lt;div&gt;    下面说说，使用debian官方的包如何做uwsgi发布，还是vhost模式哦。&lt;/div&gt;&lt;div&gt;    首先安装uwsgi，uwsgi-plugin-python这两个包。uwsgi-plugin-greenlet-python也可以考虑，装不装看你的需求。&lt;/div&gt;&lt;div&gt;    然后在/etc/uwsgi/apps-available/sites.xml下面写一个文本文件，内容如下：&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;uwsgi&amp;gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;    &lt;/span&gt;&amp;lt;vhost/&amp;gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt; &lt;/span&gt;&amp;lt;no-site/&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;lt;/uwsgi&amp;gt;&lt;/div&gt;&lt;/div&gt; &lt;div&gt;    再从/etc/uwsgi/apps-enabled/sites.xml链接过去，重启uwsgi服务，事情就搞定了。&lt;/div&gt;&lt;div&gt;    默认的配置在/usr/share/uwsgi/conf/default.ini，可以看看是否都满意了。一般来说，master和no-orphans都建议打开，chmod-socket最高660，改成600应该也可以工作。贝壳的机器负载小，只用一个worker就够了，所以完整的配置是这样的：&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;&lt;div&gt;&amp;lt;uwsgi&amp;gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;  &lt;/span&gt;&amp;lt;plugins&amp;gt;greenlet,ugreen&amp;lt;/plugins&amp;gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt; &lt;/span&gt;&amp;lt;workers&amp;gt;1&amp;lt;/workers&amp;gt;&lt;/div&gt; &lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;  &lt;/span&gt;&amp;lt;reload-on-as&amp;gt;128&amp;lt;/reload-on-as&amp;gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;   &lt;/span&gt;&amp;lt;vhost/&amp;gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt; &lt;/span&gt;&amp;lt;no-site/&amp;gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;&amp;lt;/uwsgi&amp;gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;    nginx里面如此设定：&lt;/div&gt;&lt;div&gt;&lt;div&gt;location /asdf {&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt; &lt;/span&gt; include&lt;span style=&#34;white-space:pre-wrap&#34;&gt;  &lt;/span&gt;uwsgi_params;&lt;/div&gt; &lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt; &lt;/span&gt; uwsgi_param&lt;span style=&#34;white-space:pre-wrap&#34;&gt;  &lt;/span&gt;UWSGI_PYHOME /usr;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt; &lt;/span&gt; uwsgi_param&lt;span style=&#34;white-space:pre-wrap&#34;&gt;  &lt;/span&gt;UWSGI_CHDIR /var/web/hosts;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;   &lt;/span&gt; uwsgi_param&lt;span style=&#34;white-space:pre-wrap&#34;&gt;  &lt;/span&gt;UWSGI_SCRIPT main;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt; &lt;/span&gt; uwsgi_pass&lt;span style=&#34;white-space:pre-wrap&#34;&gt;   &lt;/span&gt;unix:/run/uwsgi/sites/socket;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;}&lt;/div&gt;&lt;/div&gt;&lt;div&gt;    其中，我的程序放在/var/web/hosts底下，使用系统环境来运行（而不是virtualenv），主脚本（带applications那个）是main.py。unix socket和上文default.ini里面的socket正好对应上。&lt;/div&gt;&lt;div&gt;    同理，我们其实还可以开多个uwsgi应用，只要放置多个xml配置就好。不过既然都采用了vhost模式，何必还开多个呢？这毕竟不是虚拟网站，要给其他人使用的。&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用uwsgi搭建python应用</title>
      <link>http://shell909090.org/blog/archives/1811/</link>
      <pubDate>Wed, 25 May 2011 11:08:38 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1811/</guid>
      <description>&lt;p&gt;&amp;nbsp; &amp;nbsp;wsgi是python的一个标准web服务接口，具体去google pep文档，不解释。在李木头的忽悠下，贝壳试用了一下uwsgi搭建python服务器，感觉还不错。
&amp;nbsp; &amp;nbsp;首先，贝壳将uwsgi打包成deb包，因为这东西和python基本没什么关系，就是一个标准的系统守护服务程序。其中贝壳测试了一下，uwsgi编译的时候是依赖版本的。所以请教了一下thomas，打了uwsgi2.6和uwsgi2.7两个包。没办法，mercurial对python2.7的支持不是很好，每次都出问题。具体的可以加贝壳的repos: &lt;a href=&#34;http://shell909090.org/debian/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://shell909090.org/debian/&#34;&gt;http://shell909090.org/debian/&lt;/a&gt;&lt;/a&gt;&lt;span style=&#34;min-height: 16px; padding-right: 16px; width: 16px;&#34;&gt;&lt;/span&gt; testing，然后通过一下贝壳的key，就可以直接安装uwsgi2.6了。当然，不通过key也可以，只是每次安装升级都有警告。
&amp;nbsp; &amp;nbsp;贝壳写了一个很简单的init.d，使用&amp;ndash;vhost来启动uwsgi为服务模式。这种模式的好处是，uwsgi的具体执行的应用都是由nginx来确定的，因此所有的映射只需要修改nginx配置就好。uwsgi参数很多，包括可以指定内存限制，工作进程/线程，定时重启工作进程，多解释器等等。是一个高效的，功能强大的服务器。具体可以自己参考调整。最好的的地方是，uwsgi还支持virtualenv，你可以给不同的应用建立不同的工作环境，从而在环境中使用指定的包，而不是系统包。
&amp;nbsp; &amp;nbsp;下面是一个nginx配置的例子。
&amp;nbsp; &amp;nbsp; &amp;nbsp; location /ticket {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;include uwsgi_params;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param UWSGI_PYHOME /usr;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param UWSGI_CHDIR /home/shell/workspace/hg/thost;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param UWSGI_SCRIPT main;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_pass unix:/var/run/uwsgi.socket;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;location /mlocate {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;include uwsgi_params;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param UWSGI_PYHOME /usr;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param UWSGI_CHDIR /home/shell/workspace/hg/thost;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param UWSGI_SCRIPT main;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_pass unix:/var/run/uwsgi.socket;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;location /hg {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;include uwsgi_params;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param UWSGI_PYHOME /usr;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param UWSGI_CHDIR /home/shell/workspace/hg;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param UWSGI_SCRIPT hgweb;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param SCRIPT_NAME /;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_param SERVER_NAME hgweb;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;uwsgi_pass unix:/var/run/uwsgi.socket;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;}
&amp;nbsp; &amp;nbsp;这里面设定了三个应用。由于贝壳不需要virtualenv，所以PYHOME设定了/usr。第一二个应用的基础路径在/home/shell/workspace/hg/thost，脚本叫做main.py。第三个应用的基础路径在/home/shell/workspace/hg，脚本叫做hgweb.py。需要注意的是，uwsgi会以模块方式导入这些脚本，然后使用其中的application对象作为wsgi处理函数。所以不要把application对象赋值放在if &lt;strong&gt;name&lt;/strong&gt; == &amp;lsquo;&lt;strong&gt;main&lt;/strong&gt;&amp;lsquo;里面，那没用的。第三个应用指定了SCRIPT_NAME和SERVER_NAME，是因为hg的wsgi模块没有SCRIPT_NAME不工作，而这个应用和前两个不在一起，所以如果不指定SERVER_NAME会导致覆盖冲突。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 这种部署模式的好处是，我可以使用一个宿主来管理所有的应用，而不必每个应用启动一个宿主，省去了多个宿主管理的麻烦。而多进程，压力分布等等问题都被uwsgi的配置系统搞定了。于是应用程序宿主做到了彻底的免管理，即装即用，只用调节性能匹配即可。具体程序配置下放到nginx中，要修改映射关系只用管理一个位置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nginx使用fastcgi连接django时的细节</title>
      <link>http://shell909090.org/blog/archives/1694/</link>
      <pubDate>Tue, 15 Feb 2011 11:10:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1694/</guid>
      <description>&lt;p&gt;&lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;django使用PATH_INFO和SCRIPT_NAME来计算urls.py中的匹配路径，当两者都设定时，会出现URL计算结果为空，导致无法访问的问题。具体看这里。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;&lt;a href=&#34;http://aftnn.org/2009/jan/23/nginx-django-fastcgi/&#34;&gt;http://aftnn.org/2009/jan/23/nginx-django-fastcgi/&lt;/a&gt;&lt;/div&gt;  &lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何做一个mercurial的http发布</title>
      <link>http://shell909090.org/blog/archives/1618/</link>
      <pubDate>Mon, 22 Nov 2010 09:29:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1618/</guid>
      <description>&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;我假定你了解hg，了解python，理解nginx或者其他cgi/fcgi的配置过程。现在想用http发布自己的mercurial仓库，而且可能发布一群，怎么操作呢？ &lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;首先，复制模板文件过来，你可以挑选其中之一。以下是debian的文件位置，其他发布请自行查询。&lt;/div&gt;&lt;div&gt;&lt;div&gt;/usr/share/doc/mercurial-common/examples/hgweb.wsgi&lt;/div&gt;&lt;div&gt;/usr/share/doc/mercurial-common/examples/hgweb.fcgi&lt;/div&gt;&lt;div&gt;/usr/share/doc/mercurial-common/examples/hgweb.cgi&lt;/div&gt;    &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;我使用nginx+fastcgi模式部署，因此复制了hgweb.fcgi。我假定你的仓库在~/hg下面，有很多子仓库。复制hgweb.fcgi到~/hg/下，改名为hgweb.py，并修改以下两行。&lt;/div&gt;&lt;div&gt;config = &amp;quot;/path/to/you/config&amp;quot;&lt;/div&gt;&lt;div&gt;WSGIServer(application, bindAddress=&amp;#39;hgweb.sock&amp;#39;).run()&lt;/div&gt;    &lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;其中bindAddress为你需要监听的unixsocket路径，没有前缀表示在当前目录生成。而后建立配置文件，大概为以下内容。&lt;/div&gt;&lt;div&gt;&lt;div&gt;[web]&lt;/div&gt;&lt;div&gt;allow_push = someone&lt;/div&gt;&lt;div&gt;push_ssl = false&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;[paths]&lt;/div&gt;&lt;div&gt;/hg/proj1=/path/to/proj1&lt;/div&gt;    &lt;div&gt;/hg/proj2=/path/to/proj2&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;以上就完成了hgweb的服务配置，/hg/proj1是你的url映射路径，/path/to/proj1是物理路径。someone是允许进行push的人，而push_ssl是允许http推送。而后，启动服务。&lt;/div&gt;&lt;div&gt;python hgweb.py &amp;amp;&lt;/div&gt;&lt;div&gt;chmod 666 hgweb.sock&lt;/div&gt;&lt;div&gt;    &amp;nbsp;&amp;nbsp; &amp;nbsp;注意，这里要用screen之类的程序来启动hgweb，否则term关闭后服务进程停止，就没的玩了。修改权限是因为debian下的nginx使用www-data运行，对/home/user/hg没有读写权限，导致无法使用unixsock。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;在nginx中做以下配置。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;location ^~ /hg/ {&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;limit_except GET {&lt;/div&gt;   &lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;auth_basic &amp;quot;Restricted&amp;quot;;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;auth_basic_user_file /home/user/hg/users;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;fastcgi_pass &amp;nbsp; unix:/home/user/hg/hgweb.sock;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;include fastcgi_params;&lt;/div&gt;   &lt;div&gt;}&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;如果你不需要auth，可以自行参照nginx的配置修改。其他web服务器以此类推。重启服务后，&lt;a href=&#34;http://domains/hg/proj1&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://domains/hg/proj1&#34;&gt;http://domains/hg/proj1&lt;/a&gt;&lt;/a&gt;就可以访问到proj1了。&lt;/div&gt; &lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;当然，其实最后还要提一句，如果你不需要web界面，可以直接设定将文件内容直接发出去，这样也是可以做pull/push的。&lt;/div&gt;&lt;div&gt;参考：&lt;/div&gt;&lt;div&gt;&lt;a href=&#34;http://mercurial.selenic.com/wiki/PublishingRepositories&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://mercurial.selenic.com/wiki/PublishingRepositories&#34;&gt;http://mercurial.selenic.com/wiki/PublishingRepositories&lt;/a&gt;&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>以nginx作为subversion前端的一些细节</title>
      <link>http://shell909090.org/blog/archives/108/</link>
      <pubDate>Fri, 02 Apr 2010 03:40:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/108/</guid>
      <description>

&lt;p&gt;本文系电脑资料，同步到blog上。小黄姐姐不必看了，可以帮我留个言。
nginx性能不错，可惜不支持WebDAV，因此没法拿来作为subversion的http服务。于是考虑开一个nginx作为前端，后端就跑一个apache来作为容器。配置这么写的(节选)：
=========/etc/nginx/sites-enabled/default=========
server {
listen   443;
server_name  OOXX&lt;/p&gt;

&lt;p&gt;ssl  on;
ssl_certificate  keys/server.crt;
ssl_certificate_key  keys/server.key;&lt;/p&gt;

&lt;p&gt;ssl_session_timeout  5m;&lt;/p&gt;

&lt;p&gt;ssl_protocols  SSLv2 SSLv3 TLSv1;
ssl_ciphers  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
ssl_prefer_server_ciphers   on;&lt;/p&gt;

&lt;p&gt;access_log  /var/log/nginx/localhost.access.log;
include             /etc/nginx/mapping-ssl;
error_page   500 502 503 504  /50x.html;
location = /50x.html {
root   /var/www/nginx-default;
}&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;}&lt;/h1&gt;

&lt;p&gt;打开了一个https的服务，这是当然的，svn传输的数据使用http很危险。
===========/etc/nginx/mapping-ssl=============
location ^~ /svn {
proxy_set_header    Destination $http_destination;
proxy_pass          &lt;a href=&#34;http://apache_svr&#34;&gt;http://apache_svr&lt;/a&gt;;&lt;/p&gt;

&lt;p&gt;proxy_set_header    Host            $host;
proxy_set_header    X-Real-IP       $remote_addr;
proxy_set_header    X-Forwarded-Host $host;
proxy_set_header    X-Forwarded-Proto https;
proxy_set_header    X-Forwarded-Server $host;
proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;}&lt;/h1&gt;

&lt;p&gt;将/svn下面的所有请求交给apache2。
=====/etc/apache2/mods-enabled/dav_svn.conf=====
&amp;lt;Location /svn/main&amp;gt;
DAV svn&lt;/p&gt;

&lt;p&gt;SVNPath /var/web/svn/main
AuthType Basic
AuthName &amp;ldquo;Subversion Repository&amp;rdquo;
Require valid-user
AuthUserFile /var/web/svn/main/conf/passwd&lt;/p&gt;

&lt;p&gt;AuthzSVNAccessFile /var/web/svn/main/conf/authz&lt;/p&gt;

&lt;h1 id=&#34;lt-location-gt&#34;&gt;&amp;lt;/Location&amp;gt;&lt;/h1&gt;

&lt;p&gt;看起来很美，但是在使用中会发生502错误，原因是来自文件移动后，svn会使用COPY作为Verb去请求服务器端，这时候发生了这样一条日志：
==========/var/log/apache2/access.log==========&lt;/p&gt;

&lt;h1 id=&#34;127-0-0-1-user-02-apr-2010-11-07-31-0800-copy-path-http-1-0-502-546-svn-1-5-4-r33841-tortoisesvn-1-5-5-14361-neon-0-28-3&#34;&gt;127.0.0.1 - {user} [02/Apr/2010:11:07:31 +0800] &amp;ldquo;COPY {path} HTTP/1.0&amp;rdquo; 502 546 &amp;ldquo;-&amp;rdquo; &amp;ldquo;SVN/1.5.4 (r33841)/TortoiseSVN-1.5.5.14361 neon/0.28.3&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;搜索了一下，这是因为使用https作为http服务的前端造成的，这里(&lt;a href=&#34;https://secure.bonkabonka.com/blog/2008/01/04/nginx_fronting_for_subversion.html)&#34;&gt;https://secure.bonkabonka.com/blog/2008/01/04/nginx_fronting_for_subversion.html)&lt;/a&gt;提到了解决方案，而它又引用了另一个网页(&lt;a href=&#34;http://silmor.de/49)&#34;&gt;http://silmor.de/49)&lt;/a&gt;解释细节。不幸的是，这个细节是错误的。关键在于这句上
LoadModule headers_module /usr/lib/apache2/modules/mod_headers_too.so
仔细看一下就会发现，mod_headers_too应当是mod_headers。在debian下，应当执行这几条指令。
cd /etc/apache2/mods-enabled
ln -s ../mods-available/headers.load headers.load
然后，在/etc/apache2/httpd.conf中写入以下内容：
RequestHeader edit Destination ^https http early
问题解决，Q.E.D。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一个远程下载verycd的小技巧</title>
      <link>http://shell909090.org/blog/archives/89/</link>
      <pubDate>Fri, 29 Jan 2010 15:59:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/89/</guid>
      <description>&lt;p&gt;贝壳家里开了emule，天天下载，问题是又不能每次都是晚上添加资源。
怎么办呢？不知道大家知道不知道，emule是可以网络管理的，端口是4711。不过不是https，密码容易泄露。而且贝壳已经有一个nginx服务器了，也懒的再做端口映射，换端口。于是，在nginx中做如下设定。(当然，贝壳是放在https段中的)&lt;/p&gt;

&lt;p&gt;location ^~ /emule/ {
rewrite             ^/emule/(.*)$ /$1 break;
proxy_pass          &lt;a href=&#34;http://hostip:4711&#34;&gt;http://hostip:4711&lt;/a&gt;;
proxy_set_header    Host            $host;
proxy_set_header    X-Real-IP       $remote_addr;
proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;
}&lt;/p&gt;

&lt;p&gt;然后，用&lt;a href=&#34;https://dynname/emule/&#34;&gt;https://dynname/emule/&lt;/a&gt;就可以访问你家里的emule了，记得密码设强点。&lt;/p&gt;

&lt;p&gt;接下来，verycd里面曾经有复制所有连接的选项，现在没了。面对几个链接，也就手工复制一下，面对上百个连接，贝壳就无语了。贝壳试验过几个插件，都无法正确识别ed2k的链接获取。那怎么办呢？这时就要请出我们伟大的Linux。
需要准备的工具是lynx，请预先装好，然后如下操作。(范例是个动画^_^)&lt;/p&gt;

&lt;p&gt;wget -c &lt;a href=&#34;http://www.verycd.com/topics/2779234/&#34;&gt;http://www.verycd.com/topics/2779234/&lt;/a&gt;
lynx -dump -listonly index.html | grep &amp;ldquo;ed2k://&amp;rdquo; | sed &amp;ldquo;s/.*ed2k/ed2k/g&amp;rdquo; | grep -v BIG5 &amp;gt; out.txt
wc -l out.txt&lt;/p&gt;

&lt;p&gt;lynx的-dump选项是将某个网页全部渲染成文本进行展示，这是html2text的好方法，效果还不错哦，不过中文支持好像不是很好。而-listonly则是展示出页面上的所有链接，这就拿到了我们需要的原始数据。
然后，我们取其中的ed2k行，忽略其他链接，再通过sed转换，去除头部的编号和空格，这样就可以得到所有的ed2k链接。
我在下面是用-v BIG5的参数，忽略了其中繁体中文的资源，然后输出到一个文件中。数数行数，52行，大致和文件个数相当(其中好像有两个v2)。那就是可用资源了，复制到emule的控制页面中——出错？
这是因为emule的控制页面使用GET方式传递参数，因此有长度限制。你需要将链接10个一批往里面复制——有个几次就OK了。当然，如果还是多，贝壳回头会写一篇文章，介绍如何使用curl自动干这事情——这还不算太难。
这就是为啥贝壳喜欢Linux的原因了。相比Windows下的两个解决方案，找插件太费劲，自己写程序更费劲。Linux使用现有工具的组合可以轻松完成这一任务。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>