<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Shell&#39;s Home</title>
    <link>http://shell909090.org/tags/go/</link>
    <description>Recent content in Go on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Fri, 18 May 2012 07:14:24 +0800</lastBuildDate>
    <atom:link href="http://shell909090.org/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>语言的效率差异2</title>
      <link>http://shell909090.org/blog/archives/2174/</link>
      <pubDate>Fri, 18 May 2012 07:14:24 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2174/</guid>
      <description>

&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;

&lt;p&gt;为了更深入的测试语言，我做了一个经典问题——24点。&lt;/p&gt;

&lt;p&gt;这个问题主要是测试递归，循环效率，还有数组和树的复制性能。&lt;/p&gt;

&lt;p&gt;为了简化问题，方便测试，我的问题是这样描述的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;有一个数组，里面有多个正整数。有一个操作数组，其中每个都是双目操作符。找出以两者构成算式，其值等于给定值的所有表达式组合。
要求不得遗漏，可以有少量重复。例如可交换算符的交换同构暂不做排重。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际运行的时候，取+-*/和3 4 6 8，运行100次，查看时间消耗。正确的单次输出结果应当是这样的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(((8 + 4) / 3) * 6) = 24
(6 / (3 / (8 + 4))) = 24
(((8 + 4) * 6) / 3) = 24
(((8 / 4) + 6) * 3) = 24
(((8 - 6) * 3) * 4) = 24
(((8 - 6) * 4) * 3) = 24
(((3 * 4) - 8) * 6) = 24
((8 - (6 / 3)) * 4) = 24
(((4 + 8) / 3) * 6) = 24
(6 / (3 / (4 + 8))) = 24
(((4 + 8) * 6) / 3) = 24
(((8 / 4) + 6) * 3) = 24
(((4 * 3) - 8) * 6) = 24
(((8 - 6) * 3) * 4) = 24
(((8 - 6) * 4) * 3) = 24
((8 - (6 / 3)) * 4) = 24
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;python&#34;&gt;python&lt;/h1&gt;

&lt;p&gt;python的解很复杂，长达31行，以下是我写的解。当然，还有更简单的版本，我可以用eval来干这个事情，代码只有24行，但是确实给人很evil的感觉。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from itertools import combinations

class opt(object):

    def __init__(self, name, func, ex=True):
        self.name, self.func, self.exchangable = name, func, ex

    def __str__(self): return self.name

    def __call__(self, l, r): return self.func(l, r)

    def fmt(self, l, r):
        return &#39;(%s %s %s)&#39; % (fmt_exp(l), str(self), fmt_exp(r))

    def eval_exp(e):
        if not isinstance(e, tuple): return e
        try:
            return e[0](eval_exp(e[1]), eval_exp(e[2]))
        except:
            return None

    def fmt_exp(e): return e[0].fmt(e[1], e[2]) if isinstance(e, tuple) else str(e)

    def print_exp(e): print fmt_exp(e), eval_exp(e)

    def chkexp(target):
        def do_exp(e):
            if abs(eval_exp(e) - target) &amp;lt; 0.001: print fmt_exp(e), &#39;=&#39;, target
            return
        do_exp

    def iter_all_exp(f, ops, ns, e=None):
        if not ns: return f(e)
        for r in set(ns):
            ns.remove(r)
        if e is None: iter_all_exp(f, ops, ns, r)
        else:
            for op in ops:
                iter_all_exp(f, ops, ns, (op, e, r))
        if not op.exchangable:
            iter_all_exp(f, ops, ns, (op, r, e))
        ns.append(r)

opts = [
    opt(&#39;+&#39;, lambda x, y: x+y),
    opt(&#39;-&#39;, lambda x, y: x-y, False),
    opt(&#39;*&#39;, lambda x, y: x*y),
    opt(&#39;/&#39;, lambda x, y: float(x)/y, False),]

if __name__ == &#39;__main__&#39;:
for i in xrange(100): iter_all_exp(chkexp(24), opts, [3, 4, 6, 8])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是100次的时间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;real 0m2.259s
user 0m2.248s
sys  0m0.004s
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;common-lisp&#34;&gt;common lisp&lt;/h1&gt;

&lt;p&gt;lisp来解这个问题简直是作弊，难怪被叫做人工智能语言。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun chkexp (target)
  (lambda (e)
    (if (equal (ignore-errors (eval e)) target) (print e))))

(defun exchangeable (op)
  (not (member op &#39;(- /))))

(defun iter-all-exp (f ops ns &amp;amp;optional e)
  (cond
    ((not ns) (funcall f e))
    ((not e) (dolist (r (remove-duplicates ns))
           (iter-all-exp f ops (remove r ns :count 1) r)))
    (t (dolist (r (remove-duplicates ns))
     (let ((nss (remove r ns :count 1)))
       (dolist (op ops)
         (iter-all-exp f ops nss `(,op ,e ,r))
         (if (not (exchangeable op))
         (iter-all-exp f ops nss `(,op ,r ,e)))))))))

(iter-all-exp (chkexp 24) `(+ - * /) `(3 4 6 8))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有短短17行。原因在于，lisp本身的ast即是用数据结构表示的，因此根本不需要我做eval函数，也不需要画蛇添足的弄自定义算符，直接用系统算符上。显示，打印，都是现成的。需要写的只有主体逻辑。结果也很特别：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(* (- (* 3 4) 8) 6)
(* (- 8 (/ 6 3)) 4)
(* (- (* 4 3) 8) 6)
(* (/ (+ 4 8) 3) 6)
(/ 6 (/ 3 (+ 4 8)))
(/ (* (+ 4 8) 6) 3)
(* (+ (/ 8 4) 6) 3)
(* (- 8 (/ 6 3)) 4)
(* (* (- 8 6) 3) 4)
(* (* (- 8 6) 4) 3)
(* (/ (+ 8 4) 3) 6)
(/ 6 (/ 3 (+ 8 4)))
(/ (* (+ 8 4) 6) 3)
(* (+ (/ 8 4) 6) 3)
(* (* (- 8 6) 3) 4)
(* (* (- 8 6) 4) 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不但行数只有一半，速度也很让人吐血，比python快了近一倍，这是100次的结果。&lt;/p&gt;

&lt;p&gt;Evaluation&lt;/p&gt;

&lt;p&gt;took: 1.379 seconds of real time 1.372086 seconds of total run time (1.372086 user, 0.000000 system)
[ Run times consist of 0.012 seconds GC time, and 1.361 seconds non-GC time. ]
99.49% CPU 3,628,800 forms interpreted 4,127,047,350 processor cycles 102,577,080 bytes consed&lt;/p&gt;

&lt;h1 id=&#34;go&#34;&gt;go&lt;/h1&gt;

&lt;h1 id=&#34;lua&#34;&gt;lua&lt;/h1&gt;

&lt;p&gt;lua的代码是所有语言中最罗嗦的，足足长达60行，超过python许多。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function find_item(tbl, obj)
    for i, v in pairs(tbl) do
        if v == obj then return i end
    end
    return nil
end

function remove_duplicates (tbl)
    local newtbl = {}
    for i, v in pairs(tbl) do
        if find_item(newtbl, v) == nil then
       table.insert(newtbl, v)
    end
    end
    return newtbl
end

function fmt_exp (e)
    if type(e) \~= &#39;table&#39; then
       return tostring(e)
    else
    return &#39;(&#39; .. fmt_exp(e[3]) .. e[1] .. fmt_exp(e[4]) .. &#39;)&#39;
    end
end

function eval_exp (e)
    if type(e) \~= &#39;table&#39; then
       return tonumber(e)
    else
    return e[2](eval_exp(e[3]), eval_exp(e[4]))
    end
end

function chkexp (target)
    return function (e)
        if eval_exp(e) == target then
        print(fmt_exp(e))
    end
    end
end

function iter_all_exp (f, ops, ns, e)
    if table.maxn(ns) == 0 then return f(e) end
    for i, r in pairs(remove_duplicates(ns)) do
        table.remove(ns, find_item(ns, r))
    if e == nil then
        iter_all_exp(f, ops, ns, r)
    else
        for op, fp in pairs(ops) do
            iter_all_exp(f, ops, ns, {op, fp, e, r})
        if find_item(exchangable, op) == nil then
            iter_all_exp(f, ops, ns, {op, fp, r, e})
        end
        end
    end
    table.insert(ns, r)
    end
end

exchangable = {&#39;+&#39;, &#39;*&#39;}
opts = {
     [&#39;+&#39;] = function (a, b) return a + b end,
     [&#39;-&#39;] = function (a, b) return a - b end,
     [&#39;*&#39;] = function (a, b) return a * b end,
     [&#39;/&#39;] = function (a, b) return a / b end,
}

iter_all_exp(chkexp(24), opts, {3, 4, 6, 8})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实lua的代码很好看，自然语言风格，语言写出来后都能看懂。然而lua秉持了最小化内核的方针，死活不提供一些很常用的函数。我上来近15行全在写常用函数，查找某个值在表中的位置，还有除去表中的重复元素。实现下来，效率也不是特别高，基本和python相当。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;real 0m2.222s
user 0m2.184s
sys  0m0.000s
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>语言的效率差异1</title>
      <link>http://shell909090.org/blog/archives/2172/</link>
      <pubDate>Mon, 14 May 2012 02:52:27 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2172/</guid>
      <description>

&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;

&lt;p&gt;为了测试语言的效率，做一个正则解析。&lt;/p&gt;

&lt;p&gt;预先说好，正则解析的问题是老板正在做的一个实际问题，我把其他和效率无关的部分去了。因此我接受“用法不正确”这样的反驳理由，但是不接受“这不是典型用例”的理由。我欢迎你指正我的用法错误，或者对语言不了解导致的效率低下，但是别来和我吵吵这种例子太特殊。另外，在调整代码和评估速度的时候，顺便注意一下代码行数。我知道用汇编逐行写和优化会很优秀，但是这对实际工作基本没有帮助。&lt;/p&gt;

&lt;p&gt;问题是这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;有一个文本文件，每行两个数，要求解析出来这两个数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我用python生成了数据，代码是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(sys.argv[1], &#39;w&#39;) as fo:
    for i in xrange(500000):
        fo.write(&#39;%d %dn&#39; % (i, random.randint(0, 10000)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正则分析速率，是个典型的CPU密集操作。对于非编译型语言而言(这里的编译是指正则表达式的解析预编译，实际上除了lisp还真没有编译型的，即使是go也是现场拿到正则进行解析的)，这主要是看正则库的实现效率。很多时候，语言的效率问题并不取决于语言本身，还取决于语言的库的实现。大部分情况下我们都不可能砍掉系统的库重新来一个，那还不如换一门语言。&lt;/p&gt;

&lt;h1 id=&#34;python&#34;&gt;python&lt;/h1&gt;

&lt;p&gt;我首先贴出python语言的解答。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reline = re.compile(&#39;(d+) (d+)&#39;)
def main():
    with open(sys.argv[1], &#39;r&#39;) as fi:
        for line in fi: reline.match(line).groups()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是性能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;real  0m0.466s
user  0m0.436s
sys   0m0.012s
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;common-lisp&#34;&gt;common lisp&lt;/h1&gt;

&lt;p&gt;我找了N个正则包，实际能用的只有ppcre。有些包号称很快，实际测试下来还不如ppcre。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(require :cl-ppcre)

(defun grepfile (filename)
  (let*
      ((cl-ppcre:*use-bmh-matchers* t)
       (cl-ppcre:*regex-char-code-limit* 256)
       (scanner
    (cl-ppcre:create-scanner &amp;quot;d+ d+&amp;quot;)))
    (with-open-file (in filename)
      (loop
     for line = (read-line in nil) while line do
       (cl-ppcre:split scanner line)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码在slime里面测试(time (grepfile &amp;ldquo;data.dat&amp;rdquo;))，下面是结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CL-USER&amp;gt; (time (main))
Evaluation took: 0.398 seconds of real time 0.392025 seconds of total run time (0.384024 user, 0.008001 system)
[ Run times consist of 0.016 seconds GC time, and 0.377 seconds non-GC time. ]
98.49% CPU 1,188,481,425 processor cycles 72,242,256 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;go&#34;&gt;go&lt;/h1&gt;

&lt;p&gt;go的代码是现学现卖的，不知道是不是哪里写出问题了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main()
{
    f, _ := os.Open(&amp;quot;data.txt&amp;quot;)
    r := bufio.NewReader(f)
    rex, _ := regexp.Compile(&amp;quot;(d+) (d+)&amp;quot;)
    for line, isPrefix, err := r.ReadLine();err == nil &amp;amp;&amp;amp; !isPrefix; line, isPrefix, err = r.ReadLine() {
        rex.FindSubmatch(line)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果居然要差一个数量级！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;real 0m8.699s
user 0m8.593s
sys 0m0.036s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这太出乎我的意料了。google的v8引擎赫赫有名，我猜想也应当用到了go上面才是，怎么会性能差成这样？gary说过正则在他那里很快，我希望是我用错了。&lt;/p&gt;

&lt;h1 id=&#34;lua&#34;&gt;lua&lt;/h1&gt;

&lt;p&gt;lua没有使用正则包，更准确的说，lua内置的字符串处理函数可以处理这个情况。以下是我的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for line in io.lines(&amp;quot;data.txt&amp;quot;) do
    for w in string.gmatch(line, &amp;quot;%d+&amp;quot;) do
        print(w)
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是执行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;real 0m0.796s
user 0m0.792s
sys  0m0.000s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lua的代码的却很好看，但是效率上却不见得高。这是当然的，gmatch可是每工作一次就要解析一次阿。&lt;/p&gt;

&lt;h1 id=&#34;lua-rex-pcre&#34;&gt;lua-rex-pcre&lt;/h1&gt;

&lt;p&gt;装一个支持pcre的正则包，lua-rex-pcre。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r = require &amp;quot;rex_pcre&amp;quot;.new(&amp;quot;(d+) (d+)&amp;quot;, 0)
for line in io.lines(&amp;quot;data.txt&amp;quot;) do
    r.match(r, line)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，速度一下就快了不少：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;real 0m0.643s
user 0m0.632s
sys  0m0.008s
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>