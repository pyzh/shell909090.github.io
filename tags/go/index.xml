<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Shell&#39;s Home</title>
    <link>http://shell909090.org/tags/go/</link>
    <description>Recent content in Go on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Fri, 18 May 2012 07:14:24 +0800</lastBuildDate>
    <atom:link href="http://shell909090.org/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>语言的效率差异2</title>
      <link>http://shell909090.org/blog/archives/2174/</link>
      <pubDate>Fri, 18 May 2012 07:14:24 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2174/</guid>
      <description>&lt;div&gt;

\# 问题 \#

&lt;/div&gt;

&lt;div&gt;

为了更深入的测试语言，我做了一个经典问题——24点。

&lt;/div&gt;

&lt;div&gt;

这个问题主要是测试递归，循环效率，还有数组和树的复制性能。

&lt;/div&gt;

&lt;div&gt;

为了简化问题，方便测试，我的问题是这样描述的：

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&amp;gt;
有一个数组，里面有多个正整数。有一个操作数组，其中每个都是双目操作符。找出以两者构成算式，其值等于给定值的所有表达式组合。

&lt;/div&gt;

&lt;div&gt;

&amp;gt; 要求不得遗漏，可以有少量重复。例如可交换算符的交换同构暂不做排重。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

实际运行的时候，取+-\*/和3 4 6
8，运行100次，查看时间消耗。正确的单次输出结果应当是这样的。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((8 + 4) / 3) \* 6) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (6 / (3 / (8 + 4))) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((8 + 4) \* 6) / 3) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((8 / 4) + 6) \* 3) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((8 - 6) \* 3) \* 4) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((8 - 6) \* 4) \* 3) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((3 \* 4) - 8) \* 6) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; ((8 - (6 / 3)) \* 4) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((4 + 8) / 3) \* 6) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (6 / (3 / (4 + 8))) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((4 + 8) \* 6) / 3) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((8 / 4) + 6) \* 3) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((4 \* 3) - 8) \* 6) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((8 - 6) \* 3) \* 4) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (((8 - 6) \* 4) \* 3) = 24

&lt;/div&gt;

&lt;div&gt;

&amp;gt; ((8 - (6 / 3)) \* 4) = 24

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

\# python \#

&lt;/div&gt;

&lt;div&gt;

python的解很复杂，长达31行，以下是我写的解。当然，还有更简单的版本，我可以用eval来干这个事情，代码只有24行，但是确实给人很evil的感觉。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;from
itertools import combinations

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;class
opt(object):

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    def
\_\_init\_\_(self, name, func, ex=True):

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      
 [self.name](http://self.name), self.func, self.exchangable = name,
func, ex

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    def
\_\_str\_\_(self): return [self.name](http://self.name)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    def
\_\_call\_\_(self, l, r): return self.func(l, r)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    def
fmt(self, l, r):

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      
 return &#39;(%s %s %s)&#39; % (fmt\_exp(l), str(self), fmt\_exp(r))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;def
eval\_exp(e):

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    if not
isinstance(e, tuple): return e

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    try:
return e\[0\](eval\_exp(e\[1\]), eval\_exp(e\[2\]))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    except:
return None

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;def
fmt\_exp(e): return e\[0\].fmt(e\[1\], e\[2\]) if isinstance(e, tuple)
else str(e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;def
print\_exp(e): print fmt\_exp(e), eval\_exp(e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;def
chkexp(target):

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    def
do\_exp(e):

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;        if
abs(eval\_exp(e) - target) &amp;lt; 0.001: print fmt\_exp(e), &#39;=&#39;, target

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    return
do\_exp

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;def
iter\_all\_exp(f, ops, ns, e=None):

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    if not
ns: return f(e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    for r
in set(ns):

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      
 ns.remove(r)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;        if
e is None: iter\_all\_exp(f, ops, ns, r)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      
 else:

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;          
 for op in ops:

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;          
     iter\_all\_exp(f, ops, ns, (op, e, r))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;          
     if not op.exchangable:

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;          
         iter\_all\_exp(f, ops, ns, (op, r, e))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      
 ns.append(r)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;opts = \[

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  
 opt(&#39;+&#39;, lambda x, y: x+y),

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  
 opt(&#39;-&#39;, lambda x, y: x-y, False),

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  
 opt(&#39;\*&#39;, lambda x, y: x\*y),

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  
 opt(&#39;/&#39;, lambda x, y: float(x)/y, False),\]

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;if
\_\_name\_\_ == &#39;\_\_main\_\_&#39;:

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    for i
in xrange(100): iter\_all\_exp(chkexp(24), opts, \[3, 4, 6, 8\])

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

以下是100次的时间：

&lt;/div&gt;

&lt;div&gt;

&amp;gt; real&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m2.259s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; user&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m2.248s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; sys&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m0.004s

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

\# common lisp \#

&lt;/div&gt;

&lt;div&gt;

lisp来解这个问题简直是作弊，难怪被叫做人工智能语言。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;(defun
chkexp (target)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  (lambda
(e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    (if
(equal (ignore-errors (eval e)) target) (print e))))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;(defun
exchangeable (op)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  (not
(member op &#39;(- /))))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;(defun
iter-all-exp (f ops ns &amp;optional e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  (cond

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    ((not
ns) (funcall f e))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    ((not
e) (dolist (r (remove-duplicates ns))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      
(iter-all-exp f ops (remove r ns :count 1) r)))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    (t
(dolist (r (remove-duplicates ns))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt; (let ((nss
(remove r ns :count 1)))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   (dolist
(op ops)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    
(iter-all-exp f ops nss \`(,op ,e ,r))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;     (if
(not (exchangeable op))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;
(iter-all-exp f ops nss \`(,op ,r ,e)))))))))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;(iter-all-exp (chkexp 24) \`(+ - \* /) \`(3 4 6 8))

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

只有短短17行。原因在于，lisp本身的ast即是用数据结构表示的，因此根本不需要我做eval函数，也不需要画蛇添足的弄自定义算符，直接用系统算符上。显示，打印，都是现成的。需要写的只有主体逻辑。结果也很特别：

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (- (\* 3 4) 8) 6) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (- 8 (/ 6 3)) 4) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (- (\* 4 3) 8) 6) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (/ (+ 4 8) 3) 6) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (/ 6 (/ 3 (+ 4 8))) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (/ (\* (+ 4 8) 6) 3) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (+ (/ 8 4) 6) 3) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (- 8 (/ 6 3)) 4) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (\* (- 8 6) 3) 4) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (\* (- 8 6) 4) 3) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (/ (+ 8 4) 3) 6) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (/ 6 (/ 3 (+ 8 4))) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (/ (\* (+ 8 4) 6) 3) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (+ (/ 8 4) 6) 3) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (\* (- 8 6) 3) 4) 

&lt;/div&gt;

&lt;div&gt;

&amp;gt; (\* (\* (- 8 6) 4) 3) 

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

不但行数只有一半，速度也很让人吐血，比python快了近一倍，这是100次的结果。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;Evaluation
took:

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  1.379
seconds of real time

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  1.372086
seconds of total run time (1.372086 user, 0.000000 system)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  \[ Run
times consist of 0.012 seconds GC time, and 1.361 seconds non-GC time.
\]

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  99.49%
CPU

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  3,628,800
forms interpreted

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;
 4,127,047,350 processor cycles

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;
 102,577,080 bytes consed

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

\# go \#

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

\# lua \#

&lt;/div&gt;

&lt;div&gt;

lua的代码是所有语言中最罗嗦的，足足长达60行，超过python许多。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;function
find\_item(tbl, obj)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   for i, v
in pairs(tbl) do

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      if v
== obj then return i end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   return
nil

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;function
remove\_duplicates (tbl)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   local
newtbl = {}

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   for i, v
in pairs(tbl) do

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      if
find\_item(newtbl, v) == nil then

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;
table.insert(newtbl, v)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   return
newtbl

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;function
fmt\_exp (e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   if
type(e) \~= &#39;table&#39; then

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    
 return tostring(e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   else

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    
 return &#39;(&#39; .. fmt\_exp(e\[3\]) .. e\[1\] .. fmt\_exp(e\[4\]) .. &#39;)&#39;

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;function
eval\_exp (e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   if
type(e) \~= &#39;table&#39; then

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    
 return tonumber(e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   else

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    
 return e\[2\](eval\_exp(e\[3\]), eval\_exp(e\[4\]))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;function
chkexp (target)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   return
function (e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;     if
eval\_exp(e) == target then

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;print(fmt\_exp(e))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;     end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;function
iter\_all\_exp (f, ops, ns, e)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   if
table.maxn(ns) == 0 then return f(e) end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   for i, r
in pairs(remove\_duplicates(ns)) do

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    
 table.remove(ns, find\_item(ns, r))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      if e
== nil then

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;
iter\_all\_exp(f, ops, ns, r)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      else

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt; for op, fp
in pairs(ops) do

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  
 iter\_all\_exp(f, ops, ns, {op, fp, e, r})

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    if
find\_item(exchangable, op) == nil then

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      
iter\_all\_exp(f, ops, ns, {op, fp, r, e})

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt; end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    
 table.insert(ns, r)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;exchangable
= {&#39;+&#39;, &#39;\*&#39;}

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;opts = {

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   \[&#39;+&#39;\]
= function (a, b) return a + b end,

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   \[&#39;-&#39;\]
= function (a, b) return a - b end,

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   \[&#39;\*&#39;\]
= function (a, b) return a \* b end,

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   \[&#39;/&#39;\]
= function (a, b) return a / b end,

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;}

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;iter\_all\_exp(chkexp(24), opts, {3, 4, 6, 8})

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

其实lua的代码很好看，自然语言风格，语言写出来后都能看懂。然而lua秉持了最小化内核的方针，死活不提供一些很常用的函数。我上来近15行全在写常用函数，查找某个值在表中的位置，还有除去表中的重复元素。实现下来，效率也不是特别高，基本和python相当。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&amp;gt; real&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m2.222s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; user&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m2.184s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; sys&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m0.000s

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>语言的效率差异1</title>
      <link>http://shell909090.org/blog/archives/2172/</link>
      <pubDate>Mon, 14 May 2012 02:52:27 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2172/</guid>
      <description>&lt;div&gt;

\# 问题 \#

&lt;/div&gt;

&lt;div&gt;

为了测试语言的效率，做一个正则解析。

&lt;/div&gt;

&lt;div&gt;

预先说好，正则解析的问题是老板正在做的一个实际问题，我把其他和效率无关的部分去了。因此我接受“用法不正确”这样的反驳理由，但是不接受“这不是典型用例”的理由。我欢迎你指正我的用法错误，或者对语言不了解导致的效率低下，但是别来和我吵吵这种例子太特殊。另外，在调整代码和评估速度的时候，顺便注意一下代码行数。我知道用汇编逐行写和优化会很优秀，但是这对实际工作基本没有帮助。

&lt;/div&gt;

&lt;div&gt;

问题是这样的：

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&amp;gt; 有一个文本文件，每行两个数，要求解析出来这两个数。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

我用python生成了数据，代码是这样的

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

    with open(sys.argv\[1\], &#39;w&#39;) as fo:

&lt;/div&gt;

&lt;div&gt;

        for i in xrange(500000):

&lt;/div&gt;

&lt;div&gt;

            fo.write(&#39;%d %dn&#39; % (i, random.randint(0, 10000)))

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

正则分析速率，是个典型的CPU密集操作。对于非编译型语言而言(这里的编译是指正则表达式的解析预编译，实际上除了lisp还真没有编译型的，即使是go也是现场拿到正则进行解析的)，这主要是看正则库的实现效率。很多时候，语言的效率问题并不取决于语言本身，还取决于语言的库的实现。大部分情况下我们都不可能砍掉系统的库重新来一个，那还不如换一门语言。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

\# python \#

&lt;/div&gt;

&lt;div&gt;

我首先贴出python语言的解答。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;reline =
re.compile(&#39;(d+) (d+)&#39;)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;def main():

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;with
open(sys.argv\[1\], &#39;r&#39;) as fi:

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;for line in
fi: reline.match(line).groups()

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

这是性能

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&amp;gt; real    0m0.466s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; user    0m0.436s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; sys     0m0.012s

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

\# common lisp \#

&lt;/div&gt;

&lt;div&gt;

我找了N个正则包，实际能用的只有ppcre。有些包号称很快，实际测试下来还不如ppcre。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;(require
:cl-ppcre)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;(defun
grepfile (filename)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  (let\*
((cl-ppcre:\*use-bmh-matchers\* t)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;
(cl-ppcre:\*regex-char-code-limit\* 256)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt; (scanner
(cl-ppcre:create-scanner &#34;d+ d+&#34;)))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  
 (with-open-file (in filename)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      (loop
for line = (read-line in nil) while line do

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  
(cl-ppcre:split scanner line)))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  ))

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

代码在slime里面测试(time (grepfile &#34;data.dat&#34;))，下面是结果

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;CL-USER&amp;gt;
(time (main))

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;Evaluation
took:

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  0.398
seconds of real time

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  0.392025
seconds of total run time (0.384024 user, 0.008001 system)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  \[ Run
times consist of 0.016 seconds GC time, and 0.377 seconds non-GC time.
\]

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  98.49%
CPU

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;
 1,188,481,425 processor cycles

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;
 72,242,256 bytes consed

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

\# go \#

&lt;/div&gt;

&lt;div&gt;

go的代码是现学现卖的，不知道是不是哪里写出问题了。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;func main()
{

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;f, \_ :=
os.Open(&#34;data.txt&#34;)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;r :=
bufio.NewReader(f)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;rex, \_ :=
regexp.Compile(&#34;(d+) (d+)&#34;)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;for line,
isPrefix, err := r.ReadLine();

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    err ==
nil &amp;&amp; !isPrefix;

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    line,
isPrefix, err = r.ReadLine() {

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;rex.FindSubmatch(line)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;}

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;}

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

结果居然要差一个数量级！

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&amp;gt; real&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m8.699s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; user&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m8.593s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; sys&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m0.036s

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

这太出乎我的意料了。google的v8引擎赫赫有名，我猜想也应当用到了go上面才是，怎么会性能差成这样？gary说过正则在他那里很快，我希望是我用错了。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

\# lua \#

&lt;/div&gt;

&lt;div&gt;

lua没有使用正则包，更准确的说，lua内置的字符串处理函数可以处理这个情况。以下是我的代码：

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;for line in
io.lines(&#34;data.txt&#34;) do

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   for w in
string.gmatch(line, &#34;%d+&#34;) do

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      --
print(w)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   end

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;end

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

以下是执行结果：

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&amp;gt; real&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m0.796s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; user&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m0.792s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; sys&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m0.000s

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

lua的代码的却很好看，但是效率上却不见得高。这是当然的，gmatch可是每工作一次就要解析一次阿。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

\# lua-rex-pcre \#

&lt;/div&gt;

&lt;div&gt;

装一个支持pcre的正则包，lua-rex-pcre。

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;r = require
&#34;rex\_pcre&#34;.new(&#34;(d+) (d+)&#34;, 0)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;for line in
io.lines(&#34;data.txt&#34;) do

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  
r.match(r, line)

&lt;/div&gt;

&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;end

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

OK，速度一下就快了不少：

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;

&lt;div&gt;

&amp;gt; real&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m0.643s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; user&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m0.632s

&lt;/div&gt;

&lt;div&gt;

&amp;gt; sys&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;
&lt;/span&gt;0m0.008s

&lt;/div&gt;

&lt;div&gt;

\

&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>