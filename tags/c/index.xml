<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on Shell&#39;s Home</title>
    <link>http://shell909090.org/tags/c/</link>
    <description>Recent content in C on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Tue, 30 Oct 2012 16:42:25 +0800</lastBuildDate>
    <atom:link href="http://shell909090.org/tags/c/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>异常之殇</title>
      <link>http://shell909090.org/blog/archives/2266/</link>
      <pubDate>Tue, 30 Oct 2012 16:42:25 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2266/</guid>
      <description>&lt;h1&gt;异常之殇&lt;/h1&gt;

&lt;h1&gt;辗转开解&lt;/h1&gt;

&lt;p&gt;辗转开解(stack unwinding)说的其实是这么一个现象。当执行流从深层向浅层转移时，深层调用所产生的栈上对象(stack object)需要销毁，资源需要释放。对于面对对象语言而言，往往就会执行到析构函数。&lt;/p&gt;

&lt;h2&gt;辗转开解中的异常&lt;/h2&gt;

&lt;p&gt;辗转开解真正令人迷惑之处在于，如果在析构函数中发生错误怎么办？在异常处理中发生异常，我们可以继续向上抛出。但是在辗转开解代码中出现异常，上层应当收到两个异常呢？还是一个？&lt;/p&gt;

&lt;p&gt;无论是哪种可能，都没有完美自恰的符合直觉，因此这一般是一个未定义的行为。在C++中，进程会整个彻底崩溃掉的。因此，&lt;strong&gt;千万不要在析构函数内抛出(或者可能抛出)异常&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;如果分离析构和资源销毁&lt;/h2&gt;

&lt;p&gt;一种做法是，在析构时不做资源销毁，转而提供专门的函数来执行资源销毁过程。析构只处理简单的delete等操作。然而这种做法的杯具在于，你在任何时候，一旦使用对象，都必须使用finally来保证销毁函数的调用。在发生异常时，栈上对象的辗转开解是自动的，析构函数的调用也是自动的，但是销毁函数的调用就是手工的了。&lt;/p&gt;

&lt;h1&gt;拷贝构造和隐式转换&lt;/h1&gt;

&lt;p&gt;和构造相反，对于构造函数，我们不能限制异常使用。你必须捕获构造函数的异常。&lt;/p&gt;

&lt;h2&gt;假如构造函数出了错&lt;/h2&gt;

&lt;p&gt;普通函数出错，你有两种选择。1. 异常。2. 返回值。构造函数出错，是没有选项2的。因此构造函数凡是出错必定异常。&lt;/p&gt;

&lt;p&gt;而如果构造函数可能出错，而你期望捕获他，你就不能栈上构造一个对象出来。因为这会导致栈上对象的作用域被限定在捕获他所用的try块之内。&lt;/p&gt;

&lt;h2&gt;分离构造的尝试&lt;/h2&gt;

&lt;p&gt;和析构函数类似，我们可以尝试在构造函数外，提供一个构造函数，来替代构造的初始化过程。这样可以很大程度上保证构造函数不出错。&lt;/p&gt;

&lt;p&gt;然而，首先，这样的代码就会变的复杂。每次构造函数完成调用后，都必须调用初始化函数。而且，有两种特殊的构造函数你不可能使用这种方法来解决。&lt;/p&gt;

&lt;h2&gt;拷贝构造和隐式转换&lt;/h2&gt;

&lt;p&gt;是的，这两种构造函数分别叫做拷贝构造(copy construct)和隐式转换(implicit casting)。我们举例来说。如果你在函数内建立了一个对象，你希望返回这个对象，怎么做呢？第一个思路是引用返回。不幸的是，要做引用返回，这个对象必须是堆上对象，而非栈上对象。因为栈上对象在返回后会销毁掉。如果要返回栈上对象，唯一靠谱的方案是先将对象复制到堆上，然后再复制到调用者的栈里。&lt;/p&gt;

&lt;p&gt;C++中有一类特殊的优化，叫做对象返回优化。当编译器察觉到你需要返回栈上对象时，那么编译器会直接获得调用者栈里的对象地址。这样可以避免两次的拷贝过程。然而，如果没有对象返回优化（或者没有识别出来），那么就需要两次复制以保证正确性。而C++里，默认的复制过程是内存拷贝。&lt;/p&gt;

&lt;p&gt;对于很多对象，内存拷贝是错误的行为。例如字符串，一种字符串的加速方法叫做共享内存字符串。两个字符串对象会共享一个内存块，以避免重复内容的开销。直到其中一块需要修改时，复制才真的继续。对于这种情况，直接拷贝会明显的导致错误。因此C++有一种特殊的构造函数，叫做拷贝构造。&lt;/p&gt;

&lt;p&gt;在拷贝构造的时候，调用是由C++隐式发生的，你根本没有先构造，再调用的机会和权力。因此，试图分离构造在技术上不可行。&lt;/p&gt;

&lt;p&gt;隐式转换是另一种情况。当你传递的参数和实际被赋值对象的类型不一致时（例如调用了某个函数，其参数类型不一致），C++会试图将你的对象转换为目标对象。如果是内部类型，这个被称为内部隐式转换。unsigned char可以被无错的转换为unsigned long，这个大家都知道。但是如果是对象，转换行为就需要由构造函数定义，这个叫做隐式转换构造函数。&lt;/p&gt;

&lt;p&gt;另外，隐式转换也是OO中的一大问题。我强烈建议你用explicit禁用所有隐式转换，改为显式转换。这会费一点事，但是却可以避免很多问题。&lt;/p&gt;

&lt;h1&gt;分离构造/析构的邪恶之处&lt;/h1&gt;

&lt;p&gt;ZMQ的作者曾经吐槽过这种在构造/析构之外再定义初始化/清除代码的努力。他的观点是，如果万一在构造函数中加入了代码，会引起半构造现象。为了解决这个问题，会使得整个类带上状态。我在上面已经假定这件事情不会发生了，否则代码会更加复杂，问题也更加严重。&lt;/p&gt;

&lt;h1&gt;二次异常&lt;/h1&gt;

&lt;p&gt;是的，你不应当在异常处理代码中抛出异常。当然，这里的异常指的是你的异常处理代码不应当发生异常。经过逻辑判定，当前的异常应当由更上层处理的情况不在此列。&lt;/p&gt;

&lt;p&gt;如果在异常处理中抛出异常，很可能导致的结果就是异常处理没有完成。而未完成的异常处理会发生什么问题，那只有天晓得。这个在任何带有异常系统的语言中都是成立的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>面对对象的吐槽——类型之殇</title>
      <link>http://shell909090.org/blog/archives/2265/</link>
      <pubDate>Mon, 29 Oct 2012 14:26:30 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2265/</guid>
      <description>&lt;h1&gt;继承之殇&lt;/h1&gt;

&lt;p&gt;讲继承问题，我们首先得定义什么是继承(inherit)，他是用来干吗的。&lt;/p&gt;

&lt;p&gt;所谓继承，就是当两种实体，满足其中一种必然全部都满足另一种的定义(is a)。一旦构成继承，可以带来以下好处（简单起见，我们直接就管这俩实体一个叫派生类一个叫父类）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;派生类具备父类所有已经实现的方法，毋须再实现一遍——除非需要重写(override)。&lt;/li&gt;
&lt;li&gt;派生类可以当作父类使用，凡是使用父类的地方给与派生类也对。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;继承的最主要作用，是用于复用(reuse)。&lt;/p&gt;

&lt;h1&gt;内涵和外延&lt;/h1&gt;

&lt;p&gt;形式逻辑里面有一句话，内涵越大，外延越小。在继承上，如果我们严格按照定义来做，会发生很反人类的事情。因为类的定义是依赖于内涵的，&lt;/p&gt;

&lt;p&gt;我们还是看平行四边形，长方形和正方形的例子。我们用两边长度，夹角来定义平行四边形。然后如何定义长方形？夹角为pi/2。然后如何定义正方形？两边长度相当。&lt;/p&gt;

&lt;p&gt;不知道你是否看出了问题。是的，按照正统来定义，数据的约束只会越来越多。因为派生类必须是(ISA)父类，因此父类的约束必须全部满足。我们接着上面的例子，我们为平行四边形定义一个方法，设定夹角大小。那么在长方形中，这个方法如何处理？一旦用户调用方法设定夹角大小，必然会破坏长方形定义，因此这个方法只能重写抛错。&lt;/p&gt;

&lt;p&gt;为什么？从逻辑的本源来说，平行四边形是“两组对边分别平行”，并没有说夹角的事情。到长方形的时候才说，长方形是夹角为90度的平行四边形。显然，长方形是不能设定夹角的。因此，我们要么承认，不是每个平行四边形都可以设定夹角的，例如长方形不行。要么承认，每个平行四边形都可以设定夹角，长方形不是平行四边形。显然，后者违背逻辑，我们只能得出结论，&lt;strong&gt;不是每个平行四边形都可以设定夹角&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;同样，正方形的例子也说明，不是每个平行四边形都可以设定两个分离的边长。如果以此标准来定义类，那么必然得到的是正确而无用的逻辑玩具。平行四边形没有夹角，我们就不能定义面积计算的函数，也不能——基本什么都不可以。更过分的是，我们还不能定义两个分离的边长，因为定义并没有告诉我们，边长一定不等。照此下去，我们除了一个空空荡荡的“平行四边形”这个名字外，什么都定义不下去。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，实践中，我们采取的都是，平行四边形是可以设定夹角的，然后对特例做抛错处理。这其实在本质上就违背了继承的原初意义。&lt;/p&gt;

&lt;h1&gt;继承和聚合&lt;/h1&gt;

&lt;p&gt;继承的另一个容易混淆的地方，就是分不清继承和聚合。&lt;/p&gt;

&lt;p&gt;其实从逻辑上说。继承和聚合根本就不是一回事情。例如你有(have a)一条狗，你可以让狗做任何狗可以做的事情，例如追猎物。我们可以说，你可以做的事情和狗没有区别，所以——你就是(ISA)一条狗？！&lt;/p&gt;

&lt;p&gt;傻子都不会弄错其中的区别！&lt;/p&gt;

&lt;p&gt;我们说，如果一个东西看起来像鸭子，叫起来像鸭子，走起路来像鸭子，我们就可以当他是一只鸭子，说的是弱类型语言。而且我们只能认为，我们不知道那个东西是什么(这是弱类型的特点)，总之可以当他是一只鸭子用。但是这不代表那个东西就是一只鸭子，他也可以是鸭子的代理人，或者拥有一只鸭子。在静态类型语言中，为了复用就不管三七二十一，直接声明PNG图像是一种BMP图像的——这绝对是逻辑上错误的行为。&lt;/p&gt;

&lt;p&gt;然而，你自己数数你在代码里面犯过多少次错？&lt;/p&gt;

&lt;h1&gt;多重继承&lt;/h1&gt;

&lt;p&gt;继承本身的问题我们先不说，我们再说一个很常见的问题——多重继承。&lt;/p&gt;

&lt;p&gt;既然我们说，只要一种满足ISA谓词判定，就可以认为是继承。那么理论上，我们就不能否决双重继承。例如我们定义了平行四边形，又定义了中心对称图形。那么长方形就同时是(ISA)这两者。从逻辑关系上，我们说长方形可以合法的继承两者。&lt;/p&gt;

&lt;p&gt;但是如果我们真的在程序内设定将长方形继承两者，马上会引起一连串的问题。&lt;/p&gt;

&lt;h2&gt;当多重继承发生冲突时&lt;/h2&gt;

&lt;p&gt;首先第一个是继承冲突。即当两个父类都具备同一个方法的时候，对派生类做方法调用会发生什么行为？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;肯定不能只调用一个，这会因此另一个父类的方法间发生内在不一致。这违背了继承的好处2。&lt;/li&gt;
&lt;li&gt;也不能两个都调用。两者的先后次序可能引发逻辑问题，因此先调用谁都是错误的。而且函数还有返回值问题——你返回谁的返回值呢？如果多值返回合并，这和函数原始的定义又发生了悖离，从而又违背了继承的好处2。&lt;/li&gt;
&lt;li&gt;因此，我们只能宣布这是个错误。&lt;/li&gt;
&lt;li&gt;既然是个错误，鉴于类间函数可能存在的内在联系，其他继承的函数也未必能够正常使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你看，明明是合法的多重继承，居然造成了不可复用的结果。这就是继承冲突。&lt;/p&gt;

&lt;h2&gt;菱形继承&lt;/h2&gt;

&lt;p&gt;如果说继承冲突还是一个比较好考虑的问题的话，菱形继承就是一个让人吐血的东西了。&lt;/p&gt;

&lt;p&gt;所谓菱形继承，就是两个父类继承同一个基类。在这种情况下，对父类的调用会间接转到基类上。那么，基类的函数会调用几次呢？&lt;/p&gt;

&lt;h2&gt;继承冲突的几种解法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;所有冲突的函数，父类必须都无实现。&lt;/li&gt;
&lt;li&gt;不得多重继承。这是很扯淡的，不过也是大多数时候的做法。我的编程指南之一就是——在C++中，任何时候都不要使用多重继承。&lt;/li&gt;
&lt;li&gt;使用其中一者。python是个典型的使用其中一者的例子，具体使用的按照继承编写顺序展开成MRO次序决定。然而这直接违背了继承类是(ISA)父类的定义。因此不要以为在python中，继承后总是没问题的。有的时候可能会出现继承后不能正常工作的情况。&lt;/li&gt;
&lt;li&gt;强制用户解决。要求用户必须人工定义函数，解决继承冲突的问题。从逻辑上说，如果用户定义的函数可以同时兼容于两个父类，就可以彻底化解多重继承冲突问题。然而杯具的是，很多时候在逻辑上，继承冲突是无解的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;区分接口和继承&lt;/h2&gt;

&lt;p&gt;父类没有实现冲突的函数，那么派生类中就不必纠结于调用谁的问题了。但是这引发了另一个问题——这就无法复用了。作为这一解法的极限，java不允许多重继承——除非继承的父类都是没有实现的类。这其实不是继承，而是实现(implement)接口(interface)。&lt;/p&gt;

&lt;p&gt;接口编程是一个很有道理的东西，COM里面大量着重于接口。但是接口也有自己扯淡的地方——接口是一个编写期的东西，他最大的用途就是编译期类型检查。接口并不能复用(reuse)代码。如果你有一个接口，叫做平行四边形。里面有个方法，用于计算平行四边形面积。然后你实现了长方形和正方形——那么杯具来了，你需要在两个里面通通实现一遍这个方法，即使他们基本没区别。&lt;/p&gt;

&lt;p&gt;当然，接口本身的好坏各有评价。你看，接口的唯一作用，就是声明类提供了某些函数。当我们对方法传入一个新的类的时候，我们必须将新的类也实现一下接口——哪怕这个类其实已经实现了这些方法。只要不实现接口，方法就不认可。这是强制编译器类型检查(静态类型语言)的基础。因此一般来说，静态类型语言，使用接口。动态类型语言，duck typing。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>快速深入一门语言的几个问题</title>
      <link>http://shell909090.org/blog/archives/2194/</link>
      <pubDate>Fri, 15 Jun 2012 07:19:45 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2194/</guid>
      <description>&lt;div&gt;劳资明天要结婚了，今天婚前最后一个blog。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;1.hello, world&lt;br /&gt;目标：屏幕上打印出hello, world。&lt;br /&gt;原因：不解释。&lt;div&gt;进阶：当命令行给与不同参数的时候，打印hello, 名字。给与开关的时候，打印hello, 123。&lt;br /&gt;&lt;br /&gt;&lt;div&gt;2.正则提取&lt;br /&gt;目标：写一个正则表达式(或者类似的东西)，从一段网页源码中找到某个标签的内容，去掉前后空格，显示。&lt;br /&gt;

原因：测试字符串处理能力。&lt;br /&gt;进阶：支持正则扩展&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;3.扫描排重&lt;br /&gt; 目标：将某个目录和子目录下的所有文件扫描，排除重复的文件。&lt;br /&gt; 原因：测试文件系统操作能力。&lt;/div&gt;&lt;div&gt;进阶：多线程处理，注意吞吐颠簸。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;4.做24点自动计算程序&lt;br /&gt;目标：写一个程序，能够计算24点。要求能够自定义扩展算符。&lt;br /&gt;原因：检查深度优先搜索，栈，结构设计，抽象处理能力等等。&lt;/div&gt;&lt;div&gt;进阶：做并发处理。有数种语言可能无法实现并发，或并发实现难度大，不美观，例如python。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;5.做一个计算器&lt;br /&gt;

 目标：做一个计算器，要求能计算1+2*3=7，并支持()。&lt;br /&gt;原因：表达式解析和处理需要用到程序的方方面面，字符串处理等等。&lt;/div&gt;&lt;div&gt;进阶：做一个本语言的eval函数出来。&lt;/div&gt;&lt;div&gt;&lt;br /&gt; &lt;/div&gt;&lt;div&gt;7.抓网页&lt;br /&gt;目标：实现一个服务，定期下载符合规则的一批网页，解析，获得格式化的数据，并存入数据库。&lt;/div&gt;&lt;div&gt;原因：测试系统开发能力，基础网络库，字符串处理能力。&lt;/div&gt;&lt;div&gt;进阶：分布化抓取。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;8.留言板&lt;br /&gt;目标：设计一个留言板，将所有人提交的话保存起来，能一并展示。提交不需验证，展示不需分页。&lt;br /&gt;原因：测试网络服务能力，数据库支持和多国语言支持。&lt;br /&gt;

 &lt;/div&gt;&lt;/div&gt;&lt;div&gt;进阶：防止XSS攻击。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;9.异步大并发服务器&lt;/div&gt;&lt;div&gt;目标：设计一个异步http服务器，能对请求做出响应，添加，删除，修改数据库中的数据。不得使用现有的http框架和容器。&lt;/div&gt;&lt;div&gt;原因：集成性测试&lt;/div&gt;&lt;div&gt;进阶：不使用现有数据库，自己写一个。。。&lt;/div&gt; &lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>python中调用C的几种方法</title>
      <link>http://shell909090.org/blog/archives/2176/</link>
      <pubDate>Tue, 22 May 2012 03:12:44 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2176/</guid>
      <description>&lt;div&gt;# 引言 #&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;别废话了，我觉得这都应当是常识的。除去最后几种包装框架，剩下都是基本知识问题。即使不知道怎么做，也应该知道有这种方法。所谓经验，很多时候不是把知识装脑子里，而是把索引装内存，数据丢硬盘。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# C模块 #&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;最基本的方法，直接写个C模块。具体很长，你去找python-doc，看“Extending and Embedding”这章，全看完就差不多了。如果没空，看几个例子就上也可以。&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;优点：基本没有，写起来很麻烦，要维护额外的C代码，还有交叉版本固定，跟随C升级等等麻烦。唯一的优点，就是这是唯一一个“绝对没有问题”的方法，而且没有额外依赖。如果下面几个路子全出了问题，就用C模块吧。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# ctypes #&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;去看python-doc的ctypes模块。本质上是提供一个C模块，去载入和使用其他模块。&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;优点：写起来很方便，修改便捷，而且跨各个python实现。&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;缺点：只能调用动态库，对静态库没啥办法。某些复杂数据类型的转换很麻烦，据说有时还有效率问题。&lt;/div&gt;&lt;div&gt;

&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# swig #&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;自己找，一个叫做swig的项目，目标是制作C语言的各种平台包装。实现上看，会生成一个动态库和一个py。&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;优点：跨平台多。如果你的C代码不仅是python需要调用，还有其他语言（例如php），那么swig用起来很舒服。&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;缺点：编译时引入额外依赖，而且调用范式也是受限的。不过别担心，一般你也用不到范围以外的范式。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# boost.python #&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;boost的自带库，只能用于C++。&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;优点：对C++的支持是极好的。&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;缺点：要依赖boost这么个坑爹玩意，摔。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# Pyrex #&lt;/div&gt;&lt;div&gt; &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;我知道douban的python-libmemcached是使用这个来包装的，不过没用过，不是很清楚。&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>语义的精密表达</title>
      <link>http://shell909090.org/blog/archives/2148/</link>
      <pubDate>Thu, 19 Apr 2012 03:25:34 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2148/</guid>
      <description>&lt;div&gt;    辨析语言的微妙差异，使得语言精密的符合目的语义，此为程序员基本功的最高要求。对精密语义的追求，应当凌驾于排版美观，代码美感，代码简化之上，也凌驾于运行时效率之上。除非为特定目的小幅的修正，否则不应破坏此原则。&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt; &lt;/span&gt;以此为指导，我们看几个if。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt; # if a in python #&lt;/div&gt;&lt;div&gt;    以下代码的目标语义是，如果a不为None，就运行代码。&lt;/div&gt;&lt;div&gt;`if a:&lt;/div&gt;&lt;div&gt;    do something`&lt;/div&gt;&lt;div&gt;    有什么问题？&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;  &lt;/span&gt;有没有考虑a=0的情况？a=[]呢？&lt;/div&gt; &lt;div&gt;`if a is not None:&lt;/div&gt;&lt;div&gt;    do something`&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;   &lt;/span&gt;这样才是严密表达。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# if a in C #&lt;/div&gt;&lt;div&gt;    以下代码的目标语义是，a是一个int数，对a!=0的情况下，执行代码。&lt;/div&gt; &lt;div&gt;`if (a)&lt;/div&gt;&lt;div&gt;    do something`&lt;/div&gt;&lt;div&gt;    有什么问题？&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;   &lt;/span&gt;没问题，因为C是静态语言，这限定了a的使用。除了代码并没有体现a!=0的条件，没有太大问题。但是鉴于语言表达语义，最好改为以下代码。&lt;/div&gt;&lt;div&gt;`if (a != 0)`&lt;/div&gt; &lt;div&gt;    相对的，如果a是bool型，就可以直接用了。&lt;/div&gt;&lt;div&gt;`if (a)`&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;    &lt;/span&gt;如果a是char*形，那么合适的语义表达应当是。&lt;/div&gt;&lt;div&gt;`if (a != NULL)`&lt;/div&gt;&lt;div&gt;    他们生成的汇编代码都没有差异。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt; &lt;div&gt;# if a in C++ #&lt;/div&gt;&lt;div&gt;    概念上同C，不过a是一个复杂对象。&lt;/div&gt;&lt;div&gt;`if (a)&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;    &lt;/span&gt;do something`&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;  &lt;/span&gt;有什么问题？&lt;/div&gt; &lt;div&gt;&lt;span style=&#34;white-space:pre-wrap&#34;&gt;    &lt;/span&gt;问题大了去了，和python一样，C++可以重载行为。谁知道type(a)::opreator bool(const type(a) &amp;amp;a)函数被定义为什么鬼逻辑。这就是为什么我憎恨默认行为重载的原因——因为他们对精密语义表达有破坏作用。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>值返回和指针返回简说</title>
      <link>http://shell909090.org/blog/archives/2146/</link>
      <pubDate>Wed, 18 Apr 2012 01:53:48 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2146/</guid>
      <description>&lt;p&gt;好吧，这是常识，我说快点。 &lt;div&gt;    C * c = get_c();&lt;/div&gt;&lt;div&gt;    这是指针返回。&lt;/div&gt;&lt;div&gt;    C c = get_c():&lt;/div&gt;&lt;div&gt;    这是值返回。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;    指针返回的缺点是，你必须检测返回指针的有效性，也就是NULL。并且，你需要手工管理指针释放。而优点则是避免了值拷贝，还有可以返回空值，即通过返回NULL表示没有值的情况。&lt;/div&gt;&lt;div&gt;&lt;/p&gt;

&lt;p&gt;    而引用返回最大的优势在于，变量的生存周期和作用域相同，你无需管理释放问题。然而缺陷就是庞大的拷贝开销。&lt;/div&gt;&lt;div&gt;    在get_c返回的时候，会return一个对象。这个对象是子函数作用域对象(sub function scope)，会随着子函数退出而失效。因此，在返回值的时候会引发拷贝。这种拷贝有两种可能。&lt;/div&gt;&lt;div&gt;1. 拷贝构造&lt;/div&gt;&lt;div&gt;    当返回值被用于某个对象的声明时，会触发拷贝构造函数。被返回的对象会作为拷贝构造参数传递(引用传递)，而拷贝出的对象就是被生成对象。&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;2. 赋值算子&lt;/div&gt;&lt;div&gt;    即operator =。当对某个已经声明对象进行赋值时，会发生这种现象。&lt;/div&gt;&lt;div&gt;    当然，近代编译器对于“在返回时进行构造用于返回后的构造”这种情况做了优化，通称RVO优化。例如上文，如果get_c中使用return C(a, b);进行返回，实际上只有C::C(a, b)的调用，而没有C::C(const C &amp;amp; c)的调用。&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>语言的继承和历史包袱</title>
      <link>http://shell909090.org/blog/archives/2048/</link>
      <pubDate>Sun, 01 Jan 2012 02:03:01 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2048/</guid>
      <description>&lt;p&gt;    出去玩，在阳朔过的新年，随便发点吧。&lt;br /&gt;     我们知道，C++继承了C语言的语法，并且号称完全兼容。实际玩下来，C标准自己也不怎么统一，说基本兼容大家是没异议的。这个给C++带来了无限的好处，从一开始，C++的用户数量和其他语言就不在一个数量级上。《C++语言的设计和演化》一书中说，作者设计出来后没多久，基本没有做宣传，就有无数人给他打电话，用户数量飙升。作为一个新出的语言，即使是Go也没有如此的待遇，这就是继承了C的好处。&lt;/p&gt; &lt;p&gt;    有好处就有包袱，C++兼容C，出现的包袱也很大。想做GC？想使用智能指针？那就没法兼容C（具体不细说）。此外里面有无数的问题是因为“需要兼容C”而变成一个四不像的。再后来，为了在语言上更进一步，Java继承和吸收了C++的部分语法。这给Java带来好处，也带来问题。&lt;/p&gt; &lt;p&gt;    继承一个东西的好处，就会带来一定的包袱。这个也同时体现在Zope社区和Python社区里面。Zope3把2直接推倒重来，导致了用户纷纷出走（当然还有别的原因）。从而出现目前Python Web框架满天飞，各自为战的局面。而Python3则是不完全兼容Python2，导致目前上面的可用库依然不足。在Python3.2的时候，几乎是被迫的做了一些前向兼容，来换取用户可接受的过渡。同样，前几天我在说Django的演进的时候，也说过。如果我要做一个jinja版本的Django出来，大家接受度如何？当然，这不代表你无法在Django中使用jinja，不过发行版中不会作为标配。&lt;/p&gt;

&lt;p&gt;    还有什么语言继承和革新的事情？大家不妨想想。自己做的时候，对照一下，谨慎取舍。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python内存不释放原理</title>
      <link>http://shell909090.org/blog/archives/1921/</link>
      <pubDate>Wed, 28 Sep 2011 09:57:04 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1921/</guid>
      <description>&lt;p&gt;在maillist里面看到无数次的有人问，python速度为什么这么慢，python内存管理很差。实话说，我前面已经说过了。如果你在意内存/CPU，不要用python，改用C吧。就算C不行，起码也用个go或者java。不过今天还是说说，python的内存为什么不释放。&lt;div&gt;    首先，python的初始内存消耗比C大，而且大很多。这个主要来自python解释器的开销，没什么好解释的。用解释器，就得承担解释器运行开销。然后，python中的每个对象，都有一定的对象描述成本。因此一个long为例，在C下面一般是4个字节（不用int是因为int在不同平台下是变长的），而python下面至少是16个字节。如果你生成100W个对象，那么C的内存消耗是4M，python的是16M。这些都是常规内存消耗，搞不明白的就别问了，不再解释。&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;    下面解释一下python的内存释放情况。&lt;/div&gt;&lt;div&gt;    如果是C，通常是用long array[1024 * 1024]的方法来生成1M个对象空间。当然，实际这样是不一定能运行的。因为linux的默认栈空间是8M，而Windows默认栈空间只有1M。所以代码在linux下可以通过，而windows下会跑爆掉。怎么办？下面说。当这个函数执行完毕后，当RET的时候，会自动退栈，空间就会自动释放掉（虽然在逻辑上这部分空间还是保留没有释放的，然而空间不活跃了，不过统计的时候还是占用的）。当然，更好的办法是使用malloc。malloc会从系统中自动提取和管理空间，free自动释放。这样无论是linux还是windows，都没有栈空间不足的问题。free后就会自动交还系统（4M已经超过了交还的最大阀值，一般glibc不会自己闷掉不交给系统的）。如果你忘记free，这部分内存就会一直占用，直到进程退出未知，这就是很有名的内存泄露。&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;    python下的情况更加复杂一些，python没有直接使用malloc为对象分配细粒度内存，而是使用了三层堆结构，加上三色标记进行回收。所谓三层堆，细节我们不说了，在源码阅读笔记里面写的比较详细。但是有一点需要我们记住的——当我们分配某个大小的内存的时候，内存管理器实际上是向上对齐到8字节，然后去对应的内存池中切一块出来用的。也就是说，如果我们运气比较差，申请了10个对象，偏偏每个对象大小差8字节。这样系统就要给我们分配10个堆，而不是刚刚好。如果你的对象粒度都比较散，那么内存开销比较大也不奇怪。&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;    python下还有一个更坑爹的事情，也是大部分内存不释放的根本原因。在int/str等对象的模块中，有个模块级别的对象缓存链表，static PyObject * free_list。当对象释放的时候，压根不会还到池中，而是直接在free_list中缓存。根据我的搜索，python内部没有地方对此进行干预。就是说，一旦你真的生成了1M个数字对象，然后释放。这1M个对象会在free_list链表中等待重用，直到天荒地老，这16M内存压根不会返还。而且，int的对象缓存链表和str的还不通用。如果你又做了1M个str对象，他的开销还是会继续上涨。几乎所有的内建对象都有这种机制，因此对于大规模对象同时生成，python会消耗大量内存，并且永不释放。&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;    解决的机制，基本只有用yield来将列表对象转换为生成器对象。列表对象会同时生成所有元素，从而直接分配所有内存。而生成器则是一次生成一个元素，比较节约内存。&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>从C&#43;&#43;的一个特性到设计原则再到哲学</title>
      <link>http://shell909090.org/blog/archives/1875/</link>
      <pubDate>Mon, 08 Aug 2011 09:59:46 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1875/</guid>
      <description>&lt;p&gt;最近在看C++的设计和演化，里面讲到算符重载。关于这个，Effactive C++里面明确说明，不要试图重载&amp;amp;&amp;amp;和||算符。因为这个重载造成的结果和默认不符(Not same with the default)。&lt;br /&gt;    &amp;amp;&amp;amp;和||有什么特殊？熟悉C的朋友考虑这么一个问题。if(i &amp;amp;&amp;amp; ++i)的作用是什么？基本来说，这个语句是判断i是否为0或者-1的，并且有个额外效果就是对i进行自增。但是，如果i == 0，则不进行自增，这就是&amp;amp;&amp;amp;的短路求值原则。这个原则产生了一系列写法，例如sh中常见的 [ -z &amp;quot;$ABC&amp;quot; ] &amp;amp;&amp;amp; { &amp;hellip; }。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;    不过当重载了&amp;amp;&amp;amp;或者||后，就破坏了短路求值原则。因为C系列语言是应用序语言，参数先求值。所以后参数*一定*会被求值，无论前参数的值是多少。&lt;br /&gt;    更加悲崔的是，这个破坏了最小惊讶原则，或者叫做知识内隐原则。当你使用一个知识的时候，你会根据自己的经验对这个知识做内隐的预期。例如，虽然螺丝有左螺纹也有右螺纹，然而你在拧螺丝的时候，多数预期是顺时针拧紧。不论其理由，这个已经成为常态。同样，有下压把手的门是扇页门，画着杯子的店家是咖啡店和茶馆，画着裙子的厕所是女厕，这些都是你对知识内隐的预期。破坏这个预期，相当于把螺丝改为反向，下压把手的门改成移门，画着杯子的店家是古董店，男厕画裙子一样，会让人感到不知所措。大家会莫名其妙的绕出去，确认门上画的确实是裙子，走进去再看到男厕，感到世界莫名其妙。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;    同样的道理，如果一个对象使用了&amp;amp;&amp;amp;重载，程序员唯一能够快速发现的机会就是在调试时单步了&amp;amp;&amp;amp;的语句。如果他运气不好，可能在数个小时内都找不到理由，直到反汇编目标代码为止。&lt;br /&gt;    那C++为什么设计算符重载？那是设计给需要的算符用的。其实C++一直是一个矛盾的设计，一方面他认为，程序员是不可信的，所以C++里面有隔离保护系统，例如私有成员函数和变量。另一方面，他又认为程序员应当对自己的行为负责，因此他设计了复杂的算符重载，复杂的继承系统，并期待程序员能够按照正确的方法使用。这是一个奇妙的，矛盾的设计思路，反映设计者自身的冲突（例如多人设计），或者C++设计者的实用主义倾向（选择最实用的设计）。python语言的思路相对统一，他认为程序员应当为自己的行为负责，所以python的隔离系统都是伪系统。而java的思路也相对统一，他认为程序员是不可信的，所以java才会搞出复杂的架构哲学。&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>纯C和纯C&#43;&#43;都不是好选择</title>
      <link>http://shell909090.org/blog/archives/1824/</link>
      <pubDate>Wed, 08 Jun 2011 17:30:54 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1824/</guid>
      <description>&lt;p&gt;其实严格说来，纯C是门好语言，我很欣赏纯C。但是作为程序设计，C用起来让人觉得很不方便。 &lt;ul&gt;&lt;li&gt;在标准C规范中，变量必须在块的头部声明。当然，在近代C编译器中已经取消了这个限制。&lt;/li&gt;&lt;li&gt;我提到过的，C中缺乏高级数据结构支持，导致一些简单问题的实现变得异常复杂。例如我需要解析表达式，生成lisp样子的前缀表达式。这在很多高级语言中是个很简答的事情，但是C中，你不得不自行管理内存和结构，虽然这并不算复杂。&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;    还有一些缺点不能尽述，但是经过时间的考验，C无疑是强大而具有生命力的一种语言。&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;    C++就比较搞笑了，纯C++是一个非常糟糕的东西。我们列举其缺点：&lt;/div&gt;&lt;ul&gt;&lt;li&gt;函数指针是C中常用的概念，在C++中应当使用抽象接口-实现的方式，或者使用仿函。从技术上说，在C++中使用函数指针是一个落后而没有C++特色的行为。然而无论使用哪种，生成一个新的函数就必须生成一个新的类。你当自己是java么？&lt;/li&gt;&lt;li&gt;太多internal操作，导致代码隐性错误和思考心智负荷大幅上升。例如某个类可以定义一个单参的构造函数，constructor(int c);这等于定义了一个隐性转换函数，允许将int转换为类。或者使用T operator T();算符函数，将类转换到T。如果此时错误的将类实例当作int来操作，就会产生编译通过但是运行时出错的问题。更严重的是，转换函数严重的消耗性能。在这种情况下，编译和运行都不会出错，只是莫名其妙的性能很差。要避免这个问题，可以用explicit关键字。具体可以看这里（&lt;a href=&#34;http://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html&#34;&gt;http://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html&lt;/a&gt;&lt;/a&gt;）。但是这就需要额外的知识，和随时关心自己是否会犯下这个错误的小心。&lt;/li&gt;&lt;/p&gt;

&lt;p&gt;&lt;li&gt;强大到啰嗦的模板系统。那位有信心看懂所有stl编译时报错的？反正effactive C++的作者举过一个缺陷，打印了1500个左右的字符。大部分都是符号，望之犹如天书。&lt;/li&gt;&lt;li&gt;为了支持多重继承，导致指针类型转换可能导致指针地址变换。这是一个很扯淡的缺陷，转换指针类型不会引发指针的地址转换是一个C中的基础常识。然而C++为了支持多重继承，导致这个常识被破坏。&lt;/li&gt;&lt;li&gt;thiscall和non-thiscall指针无法转换。类成员函数和普通函数指针是无法转换的。这个破坏了所有代码都可获得地址的常识。&lt;/li&gt;&lt;/p&gt;

&lt;p&gt;&lt;/ul&gt;&lt;div&gt;    其实C++的致命缺陷，就是过度设计。每一步都是很必要很有道理的改进，在最后就组合成了让人望之生畏的复杂系统。&lt;/div&gt;    要使用C++，关键就是克制自己的过度设计欲望。C++可以很容易的使用类，模板，友元系统写的很强大，而且看起来很自然。例如你可以定义自己的BioTree，使用+做合并，可以使用|运算符做输出等。然而到最后，就会变成另一种语法。并且，如果合并上大数运算库之类的库，做一个BioTree，其中元素是大数的结构。当这个结构内发生错误的时候，你觉得你能够在里面找到正确的调试方向么？&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;    要克制自己觉得很自然的想法，使用传统C中的一些做法，哪怕他们看起来很古怪，但是这是有道理的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么C语言并不适合语言入门教学</title>
      <link>http://shell909090.org/blog/archives/1666/</link>
      <pubDate>Sun, 02 Jan 2011 20:21:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1666/</guid>
      <description>&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;国内学校基本都用C语言作为入门语言教学，某本C语言教材大卖，这TMD是我看到的最蛋疼外加胡扯的事情了。你们打算把全校学生包括传媒系都培养成职业程序员么？感谢上帝，中国已经有部分学校用了java乃至python，让我不至于太绝望。 &lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;C语言作为语言之王，有着与生俱来的优势和原罪。你可以不用，但你不能无视。python的os模块基本都是底层封装，封装的是什么呢？linux下是libstdc或者是linux c api，windows下是SDK API，都是C接口而不是C++接口。因为C是一层对底层数据结构的高层抽象，主要解决兼容性问题。例如ARM/x86平台不兼容之类的问题。用C写代码的时候，就是在直观的操作底层的数据，包括内存结构，指针。正是因为这个特点，因此几乎所有平台都用C作为底层语言，并且提供C的API接口。然而也是因为同一个理由，C中缺乏高级对象支持，写一个稍稍复杂点的结构就必须动用数据结构的知识。例如你需要模拟一个园区的物流运作，因此需要写个程序。很明显，运作是以时间为顺序触发的，因此需要一个时间队列。熟悉数据结构的同学应该想到，最适合的结构应当是堆排序中的堆结构。如果没有，那么链表结构也能凑合。但是在C语言里面呢？抱歉，你需要自己实现一个链表。&lt;/div&gt;   &lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;纳尼？我它喵的为了做一个园区运作的模拟，它喵的先要啃数据结构书，然后写链表代码。你当我是计算机系的学生阿，老子是管院的。&lt;/div&gt;&lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;C++比C更适合这个问题，C++中可以使用STL，而STL中的list算是凑合的解决了这个问题。哪怕用vector，也算一种可以接受的方案了。C下面为了绕过这个问题，我用了65536长度的数组，于是程序一开就是10+M的内存。这还是我能找到的最优雅的解决方案&amp;mdash;&amp;mdash;总比自己去写一个或者用第三方链表好。java就很明显更加适合解决这个问题，它内置了list数据结构。python虽然没有list结构，但是可以用array模拟，也可以用堆结构。&lt;/div&gt;   &lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;无论如何，总好过去找第三方库吧，真当老子是IT民工啦。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;C++比C好点，但是使用C++的原罪是C++复杂的语法结构。光是类的问题上，就有静态，成员，虚三种。每种配合上public protected private，再继承一下public protected private。大约有27种情况需要记忆，它喵的这是写程序还是玩大家来找碴阿。而且还有重载，算符重载，隐性类别转换，强制类别识别这些绕死程序员的问题，我怎么看都不觉得适合给啥都不懂的非计算机系学生解决问题用。&lt;/div&gt;  &lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html; charset=utf-8&#34;&gt; &lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;非计算机系的学生，需要的是这样一门语言。好用，强大，建模和解决数学问题的能力要强，速度和安全性可以无视。很明显，C根本不合格，连边都够不上。因此在国内高校中，实际是matlab和java承担起了这个任务&amp;mdash;&amp;mdash;然而这两门都是非必修选修课，或者压根没地方教。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;有用的知识不算分，甚至没地方学，没用的垃圾要考试&amp;mdash;&amp;mdash;这个，我真&amp;mdash;&amp;mdash;无语了。。。&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么我说框架和工具不是解决安全性的良好方案</title>
      <link>http://shell909090.org/blog/archives/1663/</link>
      <pubDate>Thu, 30 Dec 2010 16:24:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1663/</guid>
      <description>&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;在python-cn的maillist上，刚刚爆发了一场关于动态语言合并出错的争论。问题的起源，来自于这样一个问题。 &lt;div&gt;一个程序员A，写了一个函数，function1。程序员B对函数进行了调用。现在两个人分别在svn上工作，A修改了function1，而b修改了其他内容。&lt;/div&gt;&lt;div&gt;由于python并不在编译时检查类别问题，因此当两人的svn merge后，运行并没有出错。现在，问题只有等上线后客户提出来了。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;几乎所有的人都同意，这问题的根源不是一个语言的问题。本质上说，这是一个工作流程问题。即使是C，也只检查参数的个数和类别，对于行为的变化和参数意义的变化还是无能为力的。&lt;/div&gt;   &lt;div&gt;1.当你公开了一个函数，并要修改这个函数的外观行为的时候，必须向其他人通告。&lt;/div&gt;&lt;div&gt;2.python代码要通过unittest和黑盒检查覆盖。&lt;/div&gt;&lt;div&gt;3.代码应当cross review。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;争论的焦点主要是在python下如何避免这个问题。楼主&lt;span class=&#34;Apple-style-span&#34; style=&#34;border-collapse: collapse; font-family: arial, sans-serif; font-size: 13px; white-space: nowrap; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; &#34;&gt;Zhang Jiawei&lt;/span&gt;的观点是使用pydev，加上工具来检查。我，沈崴，ZQ的意见是通过行为来避免这个问题。所谓行为，主要包括以下几个。&lt;/div&gt;  &lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html; charset=utf-8&#34;&gt; &lt;div&gt;1.互相review代码。&lt;/div&gt;&lt;div&gt;2.修改通告。&lt;/div&gt;&lt;div&gt;3.编写无检查和无处理的代码，并大量运行。如果代码中有错，程序会持续崩溃。因此当大量运行程序不崩溃时，代码就无错了。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;为什么我们并不推荐使用自动化工具来检测错误呢？主要是因为自动化工具可以*找到*问题，但是却不能*保证*是找到问题最彻底的一种。我举个最简单的例子：&lt;/div&gt; &lt;div&gt;网络工程师A，用了pylint，找到了自己code中的15个低级bug。他很高兴，因为工具使用起来很方便。&lt;/div&gt;&lt;div&gt;A向领导汇报了自己的心得，建议全公司推行这个工具。假定他的领导是项目经理B。&lt;/div&gt;&lt;div&gt;A：这个工具太好了，一下就找出了我15个bug，我发现用这个工具很方便，blahblahblah。&lt;/div&gt;&lt;div&gt;B：恩，很好，过两天你在公司里面讲讲这个工具。对了，你的code review做了么？&lt;/div&gt;   &lt;div&gt;A：我用工具查过拉。&lt;/div&gt;&lt;div&gt;B：你确定他找出了你的*所有*bug么？&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;问题的关键，就是*所有*。我们当然不可能找出程序中的所有bug。我所知的bug最少的程序是TeX，据说在数年的时间内只有数个bug。但是其版本号仍旧是3.1415926&amp;mdash;&amp;mdash;正好是祖率的密率&amp;mdash;&amp;mdash;而不是pi。我们毕竟不敢&amp;mdash;&amp;mdash;高伯伯也不敢&amp;mdash;&amp;mdash;保证没有bug。但是通过cross review，不处理加覆盖性检测，我们可以保证bug出现的概率在某个水平以下。&lt;/div&gt;   &lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;自动化工具寻找出的bug，是在这个水准以上的。就是说，自动化工具看的出的，人应该看的出。人看的出的，自动化工具不一定看的出。如果做不到这点，说明你的水准还不足。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;所以，当我们需要一个尽量无错的code时，当你pydev/pylint，或者其他工具做了检测，问题是否解决了呢？没有，你仍旧需要review来保证没有bug。这样一来，工具的意义在哪里呢？&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;当然，这并非说在做code review之前，你*不能*去做一遍代码扫描。只是说这样做并*不能替代*对错误的人工控制行为。&lt;/div&gt;   &lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;除非你的目标是使用最低的成本，将错误减少到一个可接受的规模&amp;mdash;&amp;mdash;而不是最低。就像我们在外包中常做的那样。这种情况下使用工具是比较合适的。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;而且一旦使用工具，很多程序员会产生依赖。所谓依赖，并不是讲从逻辑上他们不清楚在代码扫描外还需要独立的人工检测。但是在检测时，心里就会抱有一种放松的心态。尤其是其中某些虫族程序员让人无语叹息的行为。在中国的程序员界，有着诸多非常有创造力的bug提供者。例如擅长用str+=的java网页程序员很常见，这属于常见问题。但是自己写一套字典映射规则以完成数字到字符转换的（就是c下面的itoa）.net程序员真的让我大开眼界&amp;mdash;&amp;mdash;而且他同时犯下了str+=错误。要指望工具修正+=是可以的，要指望工具找出这类极品代码，估计下面会有更极品的人犯下更极品的错误。。。&lt;/div&gt;   &lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>专业程序员需要掌握的几种语言</title>
      <link>http://shell909090.org/blog/archives/116/</link>
      <pubDate>Thu, 20 May 2010 18:03:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/116/</guid>
      <description>&lt;div&gt;受到这篇文章（&lt;a href=&#34;http://blog.youxu.info/fyi/21-days/&#34;&gt;http://blog.youxu.info/fyi/21-days/&lt;/a&gt; ）的启发，我突然想起对我所会的和要学的语言做个分类。确定一下专业的程序员到底需要会多少种语言。&lt;/div&gt;
&lt;div&gt;1.系统类。只有C一个，必须学，而且需要在几个系统上编程就要学几次。学习系统类语言需要的是对系统结构和运行原理的了解，因此抽离系统的学习语法/抽象库/代码结构是没有任何意义的。&lt;/div&gt;
&lt;div&gt;2.面对对象类。C#,Java等，推荐Java。构架方法优美大气，代码容易修改容易阅读，复用性好。然而做事上架梁叠屋，吃个馒头洗三遍手。可以学习构架方法，千万别学做事方法。&lt;/div&gt;
&lt;div&gt;3.一门快速的脚本语言。Python, Php, Perl, Bash，各有特色。实际上如果你有空可以统统学一遍，非常有好处。快速脚本语言的特色就是整合其他代码和已经存在的东西，快速的构建出一个可用的程序。&lt;/div&gt;
&lt;div&gt;4.一门语法抽象语言。目前只有Lisp和Scheme，推荐Scheme。这两种语言是在人工智能和符号推理的发展过程中产生的，因此对理解“机器是如何思考的”很有帮助。注意这两种语言的本质就是有限图灵机。&lt;/div&gt;
&lt;div&gt;5.汇编。汇编语言种类太多，推荐80x86汇编。熟悉汇编语言对了解硬件和系统如何工作很有帮助，并且为查找系统内部(internal)的错误提供了便利。&lt;/div&gt;
&lt;div&gt;按照上面的分类，程序员最少要会五种语言，我假定是C/Java/Python/Scheme/Asm80x86。C++不要学，那个是万恶之源。那么下面列举了我推荐的一些书单，可以由浅而深的学习这些语言。&lt;/div&gt;
&lt;div&gt;1.入门，《21天学习C语言》《Dive Into Python》《80x86汇编基础教程》等等，这类书的目地是快速的教会是使用语言和语法。完成这个阶段的程序员可以找一些简单的题目做一下，但还不能独立完成普通程序的编写。&lt;/div&gt;
&lt;div&gt;2.简单，《Think In Java》《数据结构与算法（Java语言版）》《设计模式》。这个层面基本涉及了数据结构，设计模式和编程方法。完成这个阶段后，可以找几个实际项目玩一玩了。&lt;/div&gt;
&lt;div&gt;3.普通，《操作系统：设计和实现》《Unix系统编程》《windows核心编程》《TCP-IP详解》《Effective C》。这个层面涉及了系统运作原理和细节。完成这个阶段就可以写一些系统工具了。&lt;/div&gt;
&lt;div&gt;4.阅读，《Python源码剖析》《深入浅出MFC》《Linux内核完全注释》。这个阶段注重阅读和积累各种代码经验。&lt;/div&gt;
&lt;div&gt;5.专家，《计算机程序的构造和解释》《计算机程序设计艺术》《MIT算法导论》《数值算法》。通过前面的学习，普通程序编写应当已经不成问题。这个阶段面对的是将实际问题抽象成数学问题后，试图从数学上进行解决的过程。从此以上，就是数学的领域了。&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>软件自由英雄谱</title>
      <link>http://shell909090.org/blog/archives/78/</link>
      <pubDate>Mon, 14 Sep 2009 13:53:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/78/</guid>
      <description>&lt;p&gt;谨以此缅怀那些为了今日软件事业的自由做出贡献的先辈们。(注1: 多数人没牺牲，谢谢)(注2: 排名不分先后)(注3: 科普作品，大家别怕)
我在撰写这篇文章的时候，避免使用自由软件这个词，而改为更普遍意义上的软件自由。因为自由软件是RMS提出的一个专有词语，指软件的开源，复制，协作等 特质。而我试图通过软件自由这个词，表达人们在使用软件上的自由，以及使用软件来为我们获取自由。我们拥有知道软件一切内幕的自由，我们拥有修改软件的自 由，我们拥有思考的自由，我们拥有挑战老系统的自由，我们拥有拒绝通过软件收费的自由，我们拥有通过软件获得信息的自由，我们拥有不受任何人，包括政府监 控的自由。为了这种自由而付出的，不仅是自由程序的拥护者，也有商业程序的拥护者。
1.Richard Matthew Stallman
大名鼎鼎的RMS，GNU的核心人物，自由软件的布道者。要是在这个列表上没有他的名字，那我不知道还有谁能留在这张表上。具体可以看这里(&lt;a id=&#34;q3m2&#34; title=&#34;http://zh.wikipedia.org/zh-cn/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC&#34; href=&#34;http://zh.wikipedia.org/zh-cn/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC&#34;&gt;&lt;a href=&#34;http://zh.wikipedia.org/zh-cn/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC&#34;&gt;http://zh.wikipedia.org/zh-cn/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC&lt;/a&gt;&lt;/a&gt;)。简单来说这家伙最大的几个成就：创立了GNU和FSF，为自由软件的传播奠定了基础。制作了emacs，当今黑客世界两大编辑器之一(另一个是VIM)。制作了GCC，世界上使用最广泛的编译器。
RMS的核心想法是，因为软件而收费是罪恶的，这种人是撒旦(当然，Bill Gates是其中最大的那个)。他认为软件应当自由分享，程序员从中收取的应当是服务费。今天，RedHat正是继承了这一模式。通过免费的软件和收费的服务来进行持续的开发。
2.Linus Benedict Torvalds
常常和RMS并提的一个家伙，具体在这里(&lt;a id=&#34;g_lz&#34; title=&#34;http://zh.wikipedia.org/zh-cn/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9&#34; href=&#34;http://zh.wikipedia.org/zh-cn/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9&#34;&gt;&lt;a href=&#34;http://zh.wikipedia.org/zh-cn/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9&#34;&gt;http://zh.wikipedia.org/zh-cn/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9&lt;/a&gt;&lt;/a&gt;)。 一个低调又火爆的家伙，没有什么太多言论，但经常语出惊人，最有名的是以“一群自慰的猴子”(OpenBSD crowd is a bunch of masturbating monkeys)来形容OpenBSD的团队。最大的成就就是写了个操作系统——没错，就是叫Linux的那个。
3.Donald Ervin Knuth
哈，这个人就不像上两个那么广为人知了。他(可不能叫这家伙，得敬老)有个中文名字，叫高德纳，页面在这里(&lt;a id=&#34;txsa&#34; title=&#34;http://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E7%BA%B3&#34; href=&#34;http://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E7%BA%B3&#34;&gt;&lt;a href=&#34;http://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E7%BA%B3&#34;&gt;http://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E7%BA%B3&lt;/a&gt;&lt;/a&gt;)。 最大的成就是写了本书，叫做《计算机程序设计艺术》。有意思的是，写到一半的时候，觉得现在(那是上世纪80年代的事情)的排版软件不爽——于是自己下 手，写了一个叫做Tex的排版系统——然后再回来继续写书。这本书算起来已经写了30多年了，估计成书时间和《浮士德》有的一拼。而Tex是当今高端排版 中最流行的系统(多数都不是直接拿来用，而是用了LaTex之类的包装)，如果有向国际期刊投稿过的应该有印象。Tex也是被誉为最接近完美的程序，它的 介绍在这里(&lt;a href=&#34;http://zh.wikipedia.org/zh-cn/TeX)%E3%80%82&#34;&gt;&lt;a href=&#34;http://zh.wikipedia.org/zh-cn/TeX)。&#34;&gt;http://zh.wikipedia.org/zh-cn/TeX)。&lt;/a&gt;&lt;/a&gt;他的版本号是以圆周率为基准的，头一个版本叫3，后一个叫3.1， 以此类推。目前的版本号是3.1415926，刚好是祖冲之的密率。高伯伯曾表示，等他死之后，版本号就改为&lt;span class=&#34;texhtml&#34;&gt;π，剩下的bug就作为程序的功能放在那里。
有一个未经证实的故事。据说上世纪Internet还没出现的时候，美国军方找人设计了TCP/IP协议，他们希望有人为他们实现基于Unix的TCP /IP协议栈。于是他们花了四千万美金，找人写了一个协议栈，并且拿到高伯伯的学校去用。对此高伯伯非常不满意——别误会，我指的是实现的效果。于是就自 己花了点时间写了一个，结果比原版的协议栈更快速而稳定。美国军方觉得非常困惑，问他是怎么做的。高伯伯说，读你们的协议，然后编码。
&lt;/span&gt;4.Andrew Stuart Tanenbaum
这个知道的人也不会太多，当然，职业玩家例外。当初AT&amp;amp;T禁止UNIX7的代码公布，因此大学里面都没什么实际产品可以用来教操作系统这门课。 于是，有个叫AST的老师就怒了，你不让我干，我自己干。于是写了一个叫做Minix的系统，并且还写了本书，叫做《操作系统：设计和实现》。后来有个学 生，觉得这个系统改改能干别的，于是给AST去信。AST说，改什么改，我写这东西是拿来教书的。于是这个学生就自己写了一个系统——对了，这个学生就是 上面的Linus，而那个系统，就是大名鼎鼎的Linux。
时至今日，Minux已经发展到了第三版(他的版本号是跟着书走的，第一版，第二版，第三版&amp;hellip;)，是大多数大学里面教授操作系统基础原理的标准教材。 同时，也在嵌入式系统等领域有非常大的应用。但是，由于AST还是坚持他的教学和精简原则，因此在桌面和服务器领域就别指望了。关于AST，大家可以看这 里(&lt;a id=&#34;c2cv&#34; title=&#34;http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum&#34; href=&#34;http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum&#34;&gt;http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum&lt;/a&gt;&lt;/a&gt;)。
5.Ian Murdock
这个人很多人都听过，不过看着名字还是认不出来。他是Debian系统的作者，具体可以看这里(&lt;a id=&#34;m5_:&#34; title=&#34;http://en.wikipedia.org/wiki/Ian_Murdock&#34; href=&#34;http://en.wikipedia.org/wiki/Ian_Murdock&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Ian_Murdock&#34;&gt;http://en.wikipedia.org/wiki/Ian_Murdock&lt;/a&gt;&lt;/a&gt;)。
Debian有什么特殊呢？其实就本身来说，Debian并不算特别成功。但是Debian有庞大的衍生系统群，更有Ubuntu这样充满活力的发行。 Linux世界有所谓三大发行，四大包管理系统之说。其中三大发行指三个在世界上最广泛用于服务器的发行版本，即RedHat Enterprise Linux，SuSe， Debian，其中只有Debian是无服务商支持的。而四大包管理系统就是指RH的RPM系统，Debian的APT系统，arch的PCMAN系统， 和Gentoo的emerge系统。
6.Ken Thompson
有没有听说过？至少看着眼熟吧。这家伙是贝尔实验室的，最大成就就一个：Unix作者。详细内容请看这里(&lt;a id=&#34;f2hg&#34; title=&#34;http://en.wikipedia.org/wiki/Ken_Thompson&#34; href=&#34;http://en.wikipedia.org/wiki/Ken_Thompson&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Ken_Thompson&#34;&gt;http://en.wikipedia.org/wiki/Ken_Thompson&lt;/a&gt;&lt;/a&gt;)。
7.Dennis Ritchie
&lt;div style=&#34;text-align: left;&#34;&gt;没听说过？也很眼熟？这家伙和上面那位是朋友，最大成就也就一个：给上面那位提供了基础语言，C语言。详细内容请看这里(&lt;a id=&#34;d-g7&#34; title=&#34;http://en.wikipedia.org/wiki/Dennis_Ritchie&#34; href=&#34;http://en.wikipedia.org/wiki/Dennis_Ritchie&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Dennis_Ritchie&#34;&gt;http://en.wikipedia.org/wiki/Dennis_Ritchie&lt;/a&gt;&lt;/a&gt;)。&lt;/div&gt;
8.Bjarne Stroustrup
又是一个怎么看怎么眼熟的家伙？那当然。他和上面两位不怎么熟，不过他们都是一路的。他是C++的作者，详细内容请看这里(&lt;a id=&#34;krxr&#34; title=&#34;http://en.wikipedia.org/wiki/Bjarne_Stroustrup&#34; href=&#34;http://en.wikipedia.org/wiki/Bjarne_Stroustrup&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Bjarne_Stroustrup&#34;&gt;http://en.wikipedia.org/wiki/Bjarne_Stroustrup&lt;/a&gt;&lt;/a&gt;)。
9.Phil Katz
这个就很少有人知道了吧，不过大家肯定天天和他打交道。大家用记事本打开任意一个ZIP文件，开始的两个字肯定是PK，这就是Phil Katz，具体请看这里(&lt;a id=&#34;ihvo&#34; title=&#34;http://en.wikipedia.org/wiki/Phil_Katz&#34; href=&#34;http://en.wikipedia.org/wiki/Phil_Katz&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Phil_Katz&#34;&gt;http://en.wikipedia.org/wiki/Phil_Katz&lt;/a&gt;&lt;/a&gt;)。
这是一个有点悲剧的人物。在上个世纪的时候，大家还在BBS上混。由于速度有限，因此下载站的资源都是压缩提供的(当然，直到今天肯定还是如此)。最初的 压缩格式大多是ACE的，这是一家商业公司，直到今天还活着。由于PK不满意这家公司的压缩软件，压缩率低，速度慢，而且还不断提出高昂的收费。因此他决 定自己写一个压缩软件，就是最初的PKZIP。由于软件免费提供使用，压缩率高，解压速度快，因此很多站长自发的将数据格式转换为ZIP。后来PK就干脆 开了PKWARE软件公司，免费发行压缩程序代码，同时提供方便使用的图形界面版本。但是非常可悲的，由于格式开放，因此这个软件有个非常大的竞争 者，winzip。我想有些Win95时代的老用户还记得这个软件。PK在软件开发上很有天分，但是在市场策略上却不很成功。WinZip对ZIP格式的 熟悉其实比不上PK(那当然，人家是原作者)，然而WinZip却拥有很多用户友好的特性，右键菜单解压，虚拟解压(将压缩包的内容临时虚拟成一个目录， 用户可以无缝的使用，XP中集成了这个功能，但是WinZip的虚拟解压很容易撤销)。所以最终PK的软件公司破产了。他本人在2000年4月14日因饮 酒过度，在一家小旅馆内死去。
至于WinZip呢？碰到了一个更强大的对手，WinRar。功能类似，但更简洁，最主要是支持大多数流行的压缩格式。因此目前压缩软件领域还是WinRar占据着主流，市场就是这么残酷。
10.Phil Zimmermann
这个人基本没人知道，但是却是这张表里面最典型和突出的一个人。他是PGP的作者，具体可以看这里(&lt;a id=&#34;viz0&#34; title=&#34;http://en.wikipedia.org/wiki/Philip_Zimmermann&#34; href=&#34;http://en.wikipedia.org/wiki/Philip_Zimmermann&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Philip_Zimmermann&#34;&gt;http://en.wikipedia.org/wiki/Philip_Zimmermann&lt;/a&gt;&lt;/a&gt;)。他的成就很难用一句话说明，要阐明他的成就，就必须从美国的国家安全出口管制说起。
在上个世纪，美国政府有一种观点，他们需要能随时随地的窃听任何一个人和其他人的通讯。同时，作为延伸，他们制定了国家安全出口法案，将密码产品作为军用 管制品，限制出口。这其实是很荒谬和不合逻辑的，任何公开的算法都可以被多个人独立的实现。只要算法是公开的，即使产品不允许出口，国外也可以没有任何阻 碍的实现出来。而如果算法是不公开的，则会出现两个弊端。一个是阻碍密码学的交流和进步，更麻烦的是，根据密码学的内在逻辑，这样的系统，由于验证不完 全，因此比公开的系统更加不安全。
在1991年前后，PZ制作了PGP软件，用于保障当时备受争议的电子邮件的安全(小常识: 电子邮件默认是明文的，安全程度和你写在明信片背面寄给你父母的句子差不多)。这个软件使用了1980年以来提出的现代密码系统几大密码系统，实现了签名 安全和秘密安全。这里我们小小的讲解一下电子邮件的两大安全系统，对此无爱的人自行跳到下一段。签名安全就是指，你收到一个邮件的时候，能够确信，这个信 的内容是原始发件人的真实意思表示，而不是被篡改过的。秘密安全就是指，当你收到一个信的时候，你能够确信，除了你没有别人能够偷看到内容。对此，一般采 用公钥系统来实现两者的安全。所谓公钥系统是这样一种系统，用公钥加密必须用私钥解密，用私钥加密必须用公钥解密，私钥很容易计算出公钥，公钥非常难计算 出私钥。当你要签名安全的时候，将邮件内容用自己的私钥加密再发送一次(实际是将内容hash了再加密的)，接收者解密后对比。由于篡改者只有公钥，因此 虽然可以拦截和修改内容，但是无法伪造出一对匹配的内容，用公钥解密后刚好一致。而秘密安全则是用对方的公钥加密。对于更高层级的要求，你的公钥不仅要求 公布，而且必须在国家认可的部门公布，这样就由国家认定了你的公钥和你的身份的一致性。当你对一个内容签署的时候，只要能用公钥验证签名，就可以认定内容 是你的真实意思表述，并被法律所承认。
当时的PGP当然还没有这么复杂，但是对于当时缺乏任何安全性特征(当时连TLS都没有)的电子邮件来说，是非常必要的补充。可是我们上文说了，美国禁止 出口这些产品。于是，PZ免费的将软件的最初版本散发给同事和其他人使用，而这些人又可以免费的分发出去——这和自由模式非常的吻合，除了我找不到具体信 息标明当时PZ是否从授权上同意他们做这个事情。法律上说，PZ并没有“出口”密码产品，但是实际上，是他实现并且向全世界推广了高强度的电子邮件安全系 统。从某种意义上说，PZ可以说是叛国者。非法散布军用管制品，危害美国的国家安全(这还不像中国那种含糊不清的指控，这里的军用管制品定义是明确的，并 且是由国会制定的)。于是，PZ受到了三年的官司和五年的调查，直到96年的时候，克林顿签署了新的法案，放松了密码产品的出口限制。其实也没松多少，从 40位到56位——大概就是从5个字符到7个字符的区别。反之，我们改变观点，从世界的角度说，由于他的勇气和决心，我们每个人从中受益匪浅。
必须得说，其实这一改变很大程度上并不是PZ个人努力或者公民运动的结果，其中有巨大的商业力量。IBM，微软和Lotus之类的跨国软件巨头在出口产品 的时候，由于受到出口限制，因此在海外产品上的安全性一直很成问题。很多时候他们因为这个问题受到了巨大的挑战。在这一问题上，他们有足够的理由去游说白 宫，改变出口限制的要求。关于这个案件的其他资料，可以参考这里(&lt;a id=&#34;pend&#34; title=&#34;http://cyberlaw.stanford.edu/~prz/ZH/faq/index.html&#34; href=&#34;http://cyberlaw.stanford.edu/%7Eprz/ZH/faq/index.html&#34;&gt;&lt;a href=&#34;http://cyberlaw.stanford.edu/~prz/ZH/faq/index.html&#34;&gt;http://cyberlaw.stanford.edu/~prz/ZH/faq/index.html&lt;/a&gt;&lt;/a&gt;)和这里(&lt;a id=&#34;zt16&#34; title=&#34;http://www.techcn.com.cn/index.php?doc-view-130949&#34; href=&#34;http://www.techcn.com.cn/index.php?doc-view-130949&#34;&gt;&lt;a href=&#34;http://www.techcn.com.cn/index.php?doc-view-130949&#34;&gt;http://www.techcn.com.cn/index.php?doc-view-130949&lt;/a&gt;&lt;/a&gt;)。
在今日，PGP仍旧是一个非常强大的加密系统，并且是开源的——理所当然，如果不开源，我们会担心其中是否有漏洞和后门继续危害我们的安全。并且，从密码 学内在的逻辑来说，不公开的系统是不安全的。不过他仍旧受限于美国国家安全出口管制条例，原因是因为由于今日强大的计算能力，因此密钥通常的长度是 1024，2048，4096位长的——远远超过美国国家限制数十倍。因此这一软件的强密钥版本只有英文版，因为不用考虑出口。对于海外人士来说，我们更 推荐OpenPGP，同样是开源的，而且基于开源模式开发的GNU自由软件。能够充分保证你的信息安全。
11.Lawrence Edward Larry Page
哈，在所有人中，这个是最出名的。不过在这个列表中列出此人，并非因为Google的成功，而是因为其公司“不作恶”的信条。直到今日为止，Google还良好的保持着不作恶的信条。
结尾
我们遍数评论一个个的软件自由英雄的时候，才会发现，无论在哪里，通向真正自由的路都坎坷而血腥。RMS直到快50还一直单身，到处流浪。他没有自己的汽 车、电视和房产。PZ面临了政府的指控，三年的官司，五年的调查，以及叛国者的骂名。PK更是直接挂了。当然，其中也不乏成功者，Donald Knuth和Andrew.S.Tanenbaum的书都卖的不错。Linus Torvalds和Ian Murdock也算是软件白领，收入不菲。Larry Page更是名列世界级的富豪榜。然而我们必须知道两件事情，没有他们的存在，我们就没有安全的通讯，没有廉价而优质的软件。因此，照RMS的最大对手所说的，即使没有这些人，人类也应当把它们造出来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;下的Variant</title>
      <link>http://shell909090.org/blog/archives/32/</link>
      <pubDate>Sat, 06 Sep 2008 22:50:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/32/</guid>
      <description>&lt;p&gt;所谓C++语言，是一种强类型语言。即是说，C++种的某个变量，在使用时类型是已经确定的。这个并不是设计者的喜好或者是偏心，而是C++中的变量都会被翻译成准确的内存地址和大小，如果类型不确定是不可能处理的。但是在事实中，我们经常要处理一种&amp;rdquo;变类型&amp;rdquo;。例如，我们可能需要解析表达式，这个时候我们可能用一个或者两个栈来解决这个问题。可栈里面塞的东西就精彩了，对象，函数，数据，都在里面。这时候，如果是python，我们可以直接用list，他是弱类型的。但是C++怎么办？
一般来说，我们会使用Variant类型来解决这个问题。这是C++面对对象机制和算子机制所派生出来的产物，能够让用户自行定义对象的行为。如果一个对象，可以表现的像这个又像那个，那不就解决问题了？因此在COM中就有一个variant。不过贝壳看过机制，是一堆东西的集合，非常的不美丽。今天贝壳又看到一个variant的实现，漂亮多了。
废话少说，上代码。
#include
using namespace std;
#include
using namespace boost;&lt;/p&gt;

&lt;p&gt;int _tmain(int argc, _TCHAR* argv[])
{
any a;
a = 10;
printf (&amp;ldquo;%s: %dn&amp;rdquo;, a.type ().name (), any_cast(a));
a = 10.5;
printf (&amp;ldquo;%s: %fn&amp;rdquo;, a.type ().name (), any_cast(a));
a = string (&amp;ldquo;str&amp;rdquo;);
printf (&amp;ldquo;%s: %sn&amp;rdquo;, a.type ().name (), any_cast(a).c_str ());
return 0;
}
当类型错误时，出现bad_cast exception。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>