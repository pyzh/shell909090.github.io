<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>System on Shell&#39;s Home</title>
    <link>https://shell909090.github.io/tags/system/</link>
    <description>Recent content in System on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Feb 2009 15:40:00 +0800</lastBuildDate>
    <atom:link href="https://shell909090.github.io/tags/system/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>磁盘对倒迁移</title>
      <link>https://shell909090.github.io/blog/archives/52/</link>
      <pubDate>Thu, 12 Feb 2009 15:40:00 +0800</pubDate>
      
      <guid>https://shell909090.github.io/blog/archives/52/</guid>
      <description>

&lt;p&gt;贝壳的本本坏了。
Acer的质量真不怎么的，只是正常使用而已，买来不到一个月就返修。费时费力不说，还差点因为IWT的问题无法修理而要付钱。结果刚刚过保半年，总共买了一年半后，坏了。
趁机问老板要了一台ThinkPad，虽说联想的做工不如IBM，不过依旧非常舒服，不愧是商务王者。但是，贝壳原来在笔记本上配置的复杂到死的系统，要是在新机器上一一重装的话，费力先不说，项目肯定是无法按期完工了。
贝壳修旧机器的时候，拆下了硬盘和电池。这里顺便提醒送修笔记本的同志们，记得拆下硬盘和电池。硬盘是你机要数据的所在，将来要恢复系统就全靠他了。而电池——到时候要是发现电量少了，这种东西谁都说不清楚。所以还是拆下来的好。那么，最低限度的，要从旧硬盘上读出数据，否则很多东西完全无法运作了。所以——贝壳找人借了一个移动硬盘盒。嘿嘿，这种东西可以将笔记本的SATA转换成USB使用，从而在新电脑上直接读取旧电脑数据。
为了不重装电脑，贝壳决定在新电脑上直接使用旧电脑的系统。将旧电脑的数据整个复制到新电脑上，就是俗称的磁盘对倒。下面是一个关键的问题，是重建文件系统，然后复制数据好呢？还是直接镜像整个系统？如果是复制数据，相对的数据清晰干净，但是容易发生一些莫名其妙的错误。如果是整个镜像，对了错一并带入新系统。贝壳在这里选择比较保守的方案，镜像整个磁盘。
首先贝壳从U盘启动(刚刚做了U live debian，冲着拯救去的系统，不知道是说幸运呢，还是乌鸦嘴呢)，而后删除原有磁盘的所有分区，输入dd if=/dev/sdc of=/dev/sda，将整个磁盘复制到新电脑上。这里注意，贝壳没有设定区块大小，因此速度比较慢，正确的设定大小有助于加速复制。贝壳的数据是 120G(因此向公司申请的电脑最低是120G硬盘)，复制速度是10M/s多一点，复制时间大约是3小时15分钟。从晚上9点一刻一直到晚上12点半。在完成复制后，直接重启，从硬盘启动Linux，成功！
在几乎没有任何干预的情况下，Linux就可以开机成功，不得不说这给了我很大信心。然后我去启动windows——不动。
贝壳被迫回到了Linux，仔细调试驱动，设法最快的弄出一个可用的系统。下面详细记录了ThinkPadT61上安装Debian的全过程，有兴趣的可以看看。至于六牙四皂和某猫小姐就可以跳过了。
首先贝壳调整了复制后的硬盘上的分区。由于分区表是按照120G的时候计算的，因此新硬盘上的分区使用不足。启动gparted调整大小后，sda6占用了全部新增空间，暴增到200G。而后贝壳开始查看pci设备和驱动。&lt;/p&gt;

&lt;h1 id=&#34;lspci-nn&#34;&gt;lspci -nn&lt;/h1&gt;

&lt;p&gt;00:00.0 Host bridge [0600]: Intel Corporation Mobile PM965/GM965/GL960 Memory Controller Hub &lt;a href=&#34;rev 0c&#34;&gt;8086:2a00&lt;/a&gt;
00:02.0 VGA compatible controller [0300]: Intel Corporation Mobile GM965/GL960 Integrated Graphics Controller &lt;a href=&#34;rev 0c&#34;&gt;8086:2a02&lt;/a&gt;
00:02.1 Display controller [0380]: Intel Corporation Mobile GM965/GL960 Integrated Graphics Controller &lt;a href=&#34;rev 0c&#34;&gt;8086:2a03&lt;/a&gt;
00:19.0 Ethernet controller [0200]: Intel Corporation 82566MM Gigabit Network Connection &lt;a href=&#34;rev 03&#34;&gt;8086:1049&lt;/a&gt;
00:1a.0 USB Controller [0c03]: Intel Corporation 82801H (ICH8 Family) USB UHCI Controller #4 &lt;a href=&#34;rev 03&#34;&gt;8086:2834&lt;/a&gt;
00:1a.1 USB Controller [0c03]: Intel Corporation 82801H (ICH8 Family) USB UHCI Controller #5 &lt;a href=&#34;rev 03&#34;&gt;8086:2835&lt;/a&gt;
00:1a.7 USB Controller [0c03]: Intel Corporation 82801H (ICH8 Family) USB2 EHCI Controller #2 &lt;a href=&#34;rev 03&#34;&gt;8086:283a&lt;/a&gt;
00:1b.0 Audio device [0403]: Intel Corporation 82801H (ICH8 Family) HD Audio Controller &lt;a href=&#34;rev 03&#34;&gt;8086:284b&lt;/a&gt;
00:1c.0 PCI bridge [0604]: Intel Corporation 82801H (ICH8 Family) PCI Express Port 1 &lt;a href=&#34;rev 03&#34;&gt;8086:283f&lt;/a&gt;
00:1c.1 PCI bridge [0604]: Intel Corporation 82801H (ICH8 Family) PCI Express Port 2 &lt;a href=&#34;rev 03&#34;&gt;8086:2841&lt;/a&gt;
00:1c.2 PCI bridge [0604]: Intel Corporation 82801H (ICH8 Family) PCI Express Port 3 &lt;a href=&#34;rev 03&#34;&gt;8086:2843&lt;/a&gt;
00:1c.3 PCI bridge [0604]: Intel Corporation 82801H (ICH8 Family) PCI Express Port 4 &lt;a href=&#34;rev 03&#34;&gt;8086:2845&lt;/a&gt;
00:1c.4 PCI bridge [0604]: Intel Corporation 82801H (ICH8 Family) PCI Express Port 5 &lt;a href=&#34;rev 03&#34;&gt;8086:2847&lt;/a&gt;
00:1d.0 USB Controller [0c03]: Intel Corporation 82801H (ICH8 Family) USB UHCI Controller #1 &lt;a href=&#34;rev 03&#34;&gt;8086:2830&lt;/a&gt;
00:1d.1 USB Controller [0c03]: Intel Corporation 82801H (ICH8 Family) USB UHCI Controller #2 &lt;a href=&#34;rev 03&#34;&gt;8086:2831&lt;/a&gt;
00:1d.2 USB Controller [0c03]: Intel Corporation 82801H (ICH8 Family) USB UHCI Controller #3 &lt;a href=&#34;rev 03&#34;&gt;8086:2832&lt;/a&gt;
00:1d.7 USB Controller [0c03]: Intel Corporation 82801H (ICH8 Family) USB2 EHCI Controller #1 &lt;a href=&#34;rev 03&#34;&gt;8086:2836&lt;/a&gt;
00:1e.0 PCI bridge [0604]: Intel Corporation 82801 Mobile PCI Bridge &lt;a href=&#34;rev f3&#34;&gt;8086:2448&lt;/a&gt;
00:1f.0 ISA bridge [0601]: Intel Corporation 82801HBM (ICH8M-E) LPC Interface Controller &lt;a href=&#34;rev 03&#34;&gt;8086:2811&lt;/a&gt;
00:1f.1 IDE interface [0101]: Intel Corporation 82801HBM/HEM (ICH8M/ICH8M-E) IDE Controller &lt;a href=&#34;rev 03&#34;&gt;8086:2850&lt;/a&gt;
00:1f.2 SATA controller [0106]: Intel Corporation 82801HBM/HEM (ICH8M/ICH8M-E) SATA AHCI Controller &lt;a href=&#34;rev 03&#34;&gt;8086:2829&lt;/a&gt;
00:1f.3 SMBus [0c05]: Intel Corporation 82801H (ICH8 Family) SMBus Controller &lt;a href=&#34;rev 03&#34;&gt;8086:283e&lt;/a&gt;
03:00.0 Network controller [0280]: Intel Corporation PRO/Wireless 4965 AG or AGN [Kedron] Network Connection &lt;a href=&#34;rev 61&#34;&gt;8086:4230&lt;/a&gt;
15:00.0 CardBus bridge [0607]: Ricoh Co Ltd RL5c476 II &lt;a href=&#34;rev b6&#34;&gt;1180:0476&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面我们可以看到，我们需要驱动的设备主要有有线网卡，无线网卡，声卡，显卡。下面我们针对这些设备一一查看。&lt;/p&gt;

&lt;h1 id=&#34;lspci-s-00-02-v&#34;&gt;lspci -s 00:02 -v&lt;/h1&gt;

&lt;p&gt;00:02.0 VGA compatible controller: Intel Corporation Mobile GM965/GL960 Integrated Graphics Controller (rev 0c) (prog-if 00 [VGA controller])
Subsystem: Lenovo T61
Flags: bus master, fast devsel, latency 0, IRQ 16
Memory at f8100000 (64-bit, non-prefetchable) [size=1M]
Memory at e0000000 (64-bit, prefetchable) [size=256M]
I/O ports at 1800 [size=8]
Capabilities: [90] Message Signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
Capabilities: [d0] Power Management version 3
Kernel modules: intelfb&lt;/p&gt;

&lt;p&gt;00:02.1 Display controller: Intel Corporation Mobile GM965/GL960 Integrated Graphics Controller (rev 0c)
Subsystem: Lenovo T61
Flags: bus master, fast devsel, latency 0
Memory at f8200000 (64-bit, non-prefetchable) [size=1M]
Capabilities: [d0] Power Management version 3&lt;/p&gt;

&lt;h1 id=&#34;lspci-s-00-00-v&#34;&gt;lspci -s 00:00 -v&lt;/h1&gt;

&lt;p&gt;00:00.0 Host bridge: Intel Corporation Mobile PM965/GM965/GL960 Memory Controller Hub (rev 0c)
Subsystem: Lenovo T61
Flags: bus master, fast devsel, latency 0
Capabilities: [e0] Vendor Specific Information
Kernel driver in use: agpgart-intel
Kernel modules: intel-agp&lt;/p&gt;

&lt;h1 id=&#34;lspci-s-00-1b-v&#34;&gt;lspci -s 00:1b -v&lt;/h1&gt;

&lt;p&gt;00:1b.0 Audio device: Intel Corporation 82801H (ICH8 Family) HD Audio Controller (rev 03)
Subsystem: Lenovo ThinkPad T61
Flags: bus master, fast devsel, latency 0, IRQ 17
Memory at fe020000 (64-bit, non-prefetchable) [size=16K]
Capabilities: [50] Power Management version 2
Capabilities: [60] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0 Enable-
Capabilities: [70] Express Root Complex Integrated Endpoint, MSI 00
Capabilities: [100] Virtual Channel
Capabilities: [130] Root Complex Link
Kernel driver in use: HDA Intel
Kernel modules: snd-hda-intel&lt;/p&gt;

&lt;h1 id=&#34;lspci-s-00-19-v&#34;&gt;lspci -s 00:19 -v&lt;/h1&gt;

&lt;p&gt;00:19.0 Ethernet controller: Intel Corporation 82566MM Gigabit Network Connection (rev 03)
Subsystem: Lenovo ThinkPad T61
Flags: bus master, fast devsel, latency 0, IRQ 1272
Memory at fe000000 (32-bit, non-prefetchable) [size=128K]
Memory at fe025000 (32-bit, non-prefetchable) [size=4K]
I/O ports at 1840 [size=32]
Capabilities: [c8] Power Management version 2
Capabilities: [d0] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0 Enable+
Kernel driver in use: e1000e
Kernel modules: e1000e&lt;/p&gt;

&lt;h1 id=&#34;lspci-s-03-00-v&#34;&gt;lspci -s 03:00 -v&lt;/h1&gt;

&lt;p&gt;03:00.0 Network controller: Intel Corporation PRO/Wireless 4965 AG or AGN [Kedron] Network Connection (rev 61)
Subsystem: Intel Corporation Device 1010
Flags: bus master, fast devsel, latency 0, IRQ 1273
Memory at df3fe000 (64-bit, non-prefetchable) [size=8K]
Capabilities: [c8] Power Management version 3
Capabilities: [d0] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0 Enable+
Capabilities: [e0] Express Endpoint, MSI 00
Capabilities: [100] Advanced Error Reporting
Capabilities: [140] Device Serial Number e3-9e-03-ff-ff-e0-1d-00
Kernel driver in use: iwl4965
Kernel modules: iwl4965&lt;/p&gt;

&lt;p&gt;仔细看看，其实显卡已经被默认驱动了，无法启动X是因为xorg，暂时不去理他。声卡驱动正常，有线和无线都正常。所以，贝壳首先接上了有线——果然，系统可以联网了。
而后，贝壳设置无线上网，但是——不起作用。经过仔细的查找，贝壳发现这么一件事情。虽然系统中有无线网卡驱动，但是还需要一个firmware来驱动网卡工作。这个包的名字叫做firmware-iwlwifi，安装后，系统就可以正确的使用无线了。
当然，其中还要修改一些系统配置，例如，贝壳原来的网络设备名称叫做ath0，现在叫做wlan1。首先是因为iwl驱动和madwifi的命名规则不一样。但是之所以叫做1，是因为udev的关系。打开/etc/udev/rules.d/70-persistent-net.rules，里面有很多网络设备的MAC和名称，删除后就重命名了。贝壳删除了记录，而后/etc/init.d/networking restart。系统成功的修改了名字。
下面是显卡和声卡，贝壳先搞显卡问题。打开/etc/X11/xorg.conf，删除其中指定的驱动名称，fglrx，换成intel。系统就可以成功的引导到X下面，而贝壳的系统DRI库高于7。0(testing)，于是设定了以下两个项目。
Option      &amp;ldquo;RenderAccel&amp;rdquo; &amp;ldquo;on&amp;rdquo;
Option      &amp;ldquo;DRI&amp;rdquo; &amp;ldquo;true&amp;rdquo;
进入X后声音还是不对，贝壳运行了一次alsaconf，问题解决。
而后，贝壳仔细查找了系统驱动模块，发现kvm-intel和k8-temp没有正常加载。经过查找，k8-temp的替代模块叫做acpi- cpufreq，已经被自动识别和加载。使用cpuinfo可以看到系统经处于节能模式，速度800MHZ。而kvm-intel则是原来kvm-amd 的替代模块，用于加速kvm(qemu)的运行速度。这个软件经常被贝壳用来虚拟windows。经过贝壳的查找，是BIOS中关闭了虚拟化的关系。此时可以在系统中看到如下内容，但是虚拟化无法执行。&lt;/p&gt;

&lt;h1 id=&#34;grep-vmx-proc-cpuinfo&#34;&gt;grep vmx /proc/cpuinfo&lt;/h1&gt;

&lt;p&gt;flags        : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx lm constant_tsc arch_perfmon pebs bts rep_good pni monitor ds_cpl vmx est tm2 ssse3 cx16 xtpr lahf_lm ida
flags        : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx lm constant_tsc arch_perfmon pebs bts rep_good pni monitor ds_cpl vmx est tm2 ssse3 cx16 xtpr lahf_lm ida&lt;/p&gt;

&lt;p&gt;去BIOS中，打开虚拟化设置(默认关闭)，重启，再试？没用！
原因是，这个选项修改后，必须彻底关机才能启用。仅仅重启是没有用的，奇怪吧？无论如何，关机，拔电源，接上，开机，系统可以正确的虚拟windows了，速度很快。
==，windows不是不能启动么？经过贝壳的实验，这次最奇怪的事情来了，windows可以在虚拟机上跑，但是无法在实际机器上跑——这还是个实际的windows，生产环境——
经过贝壳多次测试，还是如此。。。
下面贝壳说说一些细节问题。虽然系统正常的启动了，但是很多功能还是有问题。例如功能键不起效，亮度无法调节等等。下面一一说明怎么处理。
睡眠和待机的按钮一直起效，触摸板关闭需要添加以下一项。&lt;/p&gt;

&lt;p&gt;Section &amp;ldquo;InputDevice&amp;rdquo;
Identifier  &amp;ldquo;Synaptics Touchpad&amp;rdquo;
Driver      &amp;ldquo;synaptics&amp;rdquo;
Option      &amp;ldquo;SendCoreEvents&amp;rdquo; &amp;ldquo;true&amp;rdquo;
Option      &amp;ldquo;Device&amp;rdquo; &amp;ldquo;/dev/psaux&amp;rdquo;
Option      &amp;ldquo;Protocol&amp;rdquo; &amp;ldquo;auto-dev&amp;rdquo;
Option      &amp;ldquo;HorizScrollDelta&amp;rdquo; &amp;ldquo;0&amp;rdquo;
Option      &amp;ldquo;SHMConfig&amp;rdquo; &amp;ldquo;true&amp;rdquo;
EndSection&lt;/p&gt;

&lt;p&gt;注意最后一项SHMConfig，开启后可以用Fn+F7关闭触摸板。
而后安装hotkey-setup，很多功能键都可以了。剩下两个最主要的功能，音量和亮度。音量贝壳用自定义热键来调整了Win+Down-&amp;gt;aumix -v-10，Win+Up-&amp;gt;aumix -v+10。而亮度，贝壳自己做了一个小程序解决。&lt;/p&gt;

&lt;h1 id=&#34;cat-usr-local-bin-brightness&#34;&gt;cat /usr/local/bin/brightness&lt;/h1&gt;

&lt;p&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;/usr/local/bin/brightness&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
#!/bin/bash&lt;/p&gt;

&lt;p&gt;LCD_DEVICE=/proc/acpi/video/VID1/LCD0/brightness&lt;/p&gt;

&lt;p&gt;CURRENT=$(cat &amp;ldquo;$LCD_DEVICE&amp;rdquo; | grep current | sed &amp;ldquo;s/current: (.*)/1/&amp;ldquo;)
if [ -z $1 ]; then
echo $CURRENT
else
MOVE=$1
let &amp;lsquo;TARGET=CURRENT+MOVE&amp;rsquo;
echo $TARGET &amp;gt; $LCD_DEVICE
fi
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-end&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;

&lt;p&gt;将这个文件赋予执行权限后，记得让用户可以sudo执行，否则普通用户是无权修改/proc/acpi/video/VID1/LCD0/brightness文件的。
在安装好这个文件后，可以试试看，brightness显示当前亮度。brightness +&amp;hellip;增加亮度，brightness -&amp;hellip;降低亮度。而后绑定Win+Left-&amp;gt;brightness -10，Win+Right-&amp;gt;brightness +10。现在就可以用快捷键来修改亮度了。
下面还有一个很容易被忽视的问题，电池充电管理和磁盘抗震，首先，安装hdapsd包，他会自动安装一个内核模块补充。而后将/etc/default/hdapsd中DISK修改为sda(多数都是sda吧？)，运行以下指令加载模块。
modprobe tp_smapi
modprobe hdaps
/etc/init.d/hdapsd start
而后，我们可以如下调整电池开始充电电量
echo 40 &amp;gt; /sys/devices/platform/smapi/BAT0/start_charge_thresh
echo 90 &amp;gt; /sys/devices/platform/smapi/BAT0/stop_charge_thresh
这样只有低于40的时候才会充电，充电到90停止。根据IBM的文档，将电池电量保持在30-85%有利于增加电池寿命。贝壳截止在90，是因为会减少电池充放次数，从而很好的保护电池。当然，开始的时候本本电池很好，所以一点电也可以顶很久，于是可以设定低点。后来电池糟糕了，就必须设定高百分比开始充，这样会加速电池损耗。因此电池的寿命是越糟糕消耗的越快的。
另外，磁盘抗震可以通过hdapsd和相应模块来驱动，但是需要下载内核源码，加入补丁才可以真正起效。贝壳不高兴打补丁，而且据说2.6.28内核就会加入这个补丁，因此——等新内核吧。
最后，大家可以加入一个比较好玩的功能，笔记本的指纹识别。首先从&lt;a href=&#34;http://www.debian.org/distrib/packages搜索&#34;&gt;http://www.debian.org/distrib/packages搜索&lt;/a&gt; thinkfinger，将libthinkfinger0,libpam-thinkfinger,thinkfinger-tools依次下载安装。而后就可以用tf-tool &amp;ndash;acquire来收集指纹。一般来说，普通用户的收集总是失败，可以以root收集了放到普通用户目录中用，只需要运行tf-tool &amp;ndash;acquire $USER/.thinkfinger.bir，而后chown就可以了。另外，要使用指纹验证登录机器还需要修改pam模块，修改如下。
将/etc/pam.d/common-auth文件的原本内容注释，修改为以下内容。
auth sufficient pam_thinkfinger.so
auth required pam_unix.so nullok_secure try_first_pass
另外，如果你使用的是xdm，进入系统后发现有些变量缺失的话，可以试试看如下修改(/etc/pam.d/xdm)：&lt;/p&gt;

&lt;h1 id=&#34;id-xdm-pam-189-2005-06-11-00-04-27z-branden&#34;&gt;$Id: xdm.pam 189 2005-06-11 00:04:27Z branden $&lt;/h1&gt;

&lt;p&gt;auth        requisite    pam_nologin.so
auth        required    pam_env.so
auth        required    pam_env.so envfile=/etc/default/locale
session        required    pam_limits.so&lt;/p&gt;

&lt;p&gt;@include common-auth
@include common-account
@include common-session
@include common-password
掉换上下的顺序，事情就OK了。
经过上述的动作后，贝壳可以在新的笔记本上使用老系统的所有东西。除了windows无法在真实机器上启动之外——&lt;/p&gt;

&lt;p&gt;参考资料：
[1].Installing Debian Etch Linux on Lenovo Thinkpad T61.&lt;a href=&#34;http://ejahn.net/Members/eric/stories/t61_etch&#34;&gt;http://ejahn.net/Members/eric/stories/t61_etch&lt;/a&gt;
[2].Installing Debian Lenny on a ThinkPad T61.&lt;a href=&#34;http://www.thinkwiki.org/wiki/Installing_Debian_Lenny_on_a_ThinkPad_T61&#34;&gt;http://www.thinkwiki.org/wiki/Installing_Debian_Lenny_on_a_ThinkPad_T61&lt;/a&gt;
[3].Etch_on_Thinkpad_T61.&lt;a href=&#34;http://www.klabs.be/~fpiat/linux/debian/Etch_on_Thinkpad_T61.html&#34;&gt;http://www.klabs.be/~fpiat/linux/debian/Etch_on_Thinkpad_T61.html&lt;/a&gt;
[4].Lenny_on_Thinkpad_T61.&lt;a href=&#34;http://www.klabs.be/~fpiat/linux/debian/Lenny_on_Thinkpad_T61.html&#34;&gt;http://www.klabs.be/~fpiat/linux/debian/Lenny_on_Thinkpad_T61.html&lt;/a&gt;
[5].Linux on the Lenovo T61.&lt;a href=&#34;http://pdis.rnw.nl/~hansl/linux/T61/T61.html&#34;&gt;http://pdis.rnw.nl/~hansl/linux/T61/T61.html&lt;/a&gt;
[6].Tp smapi.&lt;a href=&#34;http://www.thinkwiki.org/wiki/Tp_smapi#Battery_charge_control_features&#34;&gt;http://www.thinkwiki.org/wiki/Tp_smapi#Battery_charge_control_features&lt;/a&gt;
[7].debian etch 简要安装指南 2007-1-26.&lt;a href=&#34;http://www.linuxsir.org/bbs/thread287473.html&#34;&gt;http://www.linuxsir.org/bbs/thread287473.html&lt;/a&gt;
[8].Debian/testing简要安装记录.&lt;a href=&#34;http://hi.baidu.com/airpot/blog/item/7e72b0b4d05de3708bd4b2d9.html&#34;&gt;http://hi.baidu.com/airpot/blog/item/7e72b0b4d05de3708bd4b2d9.html&lt;/a&gt;
[9].Debian 笔记本驱动安装.&lt;a href=&#34;http://www.unifiedkernel.com/forum/viewtopic.php?f=5&amp;amp;t=10&#34;&gt;http://www.unifiedkernel.com/forum/viewtopic.php?f=5&amp;amp;t=10&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>windows系统一</title>
      <link>https://shell909090.github.io/blog/archives/191/</link>
      <pubDate>Wed, 13 Jul 2005 23:59:26 +0800</pubDate>
      
      <guid>https://shell909090.github.io/blog/archives/191/</guid>
      <description>&lt;p&gt;一，启动
任何一个系统，一般都从启动讲起的。这里讲启动本来从NTLDR讲就好，可是怕有人不懂，所以简略概述加电后系统的启动流程。
系统加电后，会将CS:IP（注意不是EIP）设定为FFFF:0000。然后开始BIOS自检流程（Power-On Self Test,POST），最后初始化0地址的中断向量表，将引导盘CHS(0,0,1)读入系统0000:7C00开始执行。我们假定这是硬盘（软盘的没有MBR这步），并且没有安装LILO到MBR（否则流程不大一样）。于是MBR会先读取分区表（Disk Partition Table,DPT），寻找活动分区并且载入其第一扇区到000:7C00位置执行。这样MBR等于一个透明层，无论哪个分区（逻辑磁盘不行哦）获得了活动分区，其引导区（OS Boot Record,OBR）都可以当做自己是被BIOS读取执行的。而后如果是9X系统，引导区会读取系统文件（FAT32）头部来执行。这个就是我们非常熟悉的DOS启动流程。同时插句话，如果您无法format一个DOS系统盘出来。那么先彻底格式化（注意彻底，否则FAT遗留信息会让你失败）磁盘，然后COPY IO.SYS上去。照样可以产生系统盘，当然这种BT非常规手法只有了解系统才干的出来……
如果是NT系统嘛，就会按照某种方法载入NTLDR这个文件。具体方法我也不清楚。因为NTLDR文件没有位置要求支持NTFS和FAT两种格式。按理这么一来引导代码会超过引导区的容量。根据分析NT系统的引导区内容总共有六个连续扇区，分布在头六扇区中。当然第一个扇区还包含了文件系统相关信息BPB（BIOS Parameter Block，研究MFT的还有一个Extend）。这样的大小还是无法容纳整个文件系统的支持阿？要解决除非我愿意反向引导代码，不过为了这么一个问题反向引导代码……等我有空再说吧。
下面NTLDR会进入保护模式，设置了GDT,LDT等等东西，并且彻底支持了NTFS和FAT的读取（引导区只要能从两个格式盘上马找到一个文件就好）。然后会根据BOOT.ini中内容决定如何进行引导，如果出现文字，还可能需要bootfont.bin字体文件。一般来说，会直接调用NTDETECT.COM来检测硬件变化，继续系统加载过程。这个就是我们经常看到的黑色屏幕上有东西从左到右闪的那个……
后面的东西就是微软内部的资料，众人根据推理分析得来，所以不是很准确。不过可以肯定，后面的东西全在system32中打转。根据分析，首先加载的是NTOSKRNL.EXE（单处理器）或者NTKRNLPA.EXE（SMP，对称多处理器）。这个东西就是windows的微内核，由它导出了windows全部NativeAPI的实现。然后是SMSS.EXE，这是进程管理器，也可以说是头个系统派生的进程。后续所有进程可以视为它的子例。由它派生了CSRSS.EXE和WINLOGON.EXE。后者接管了系统的很多部分，例如GINA。它派生了SERVICES.EXE进程，系统开始加载各种服务。最后在登陆后由GINA启动EXPLORER.EXE。出现桌面等操作界面，启动基本完成。按照上述分析，多数服务的宿主进程都是SERVICES.EXE的派生进程（有特例，例如贝壳手里的RaidenFTPD守护进程就是先由SERVICES.EXE派生，再两次派生所成的）。而多数应用程序的进程都是EXPLORER.EXE的派生进程（当然，或者再派生进程）。EXPLORER.EXE负责的内容包括了开始菜单等等，所以除非你通过某个服务去启动程序，否则都是它的子孙。（特例包括Process Explorer工具作为Ctrl+Atl+Del启动时，是WINLOGON.EXE的子例。所以在上面启动一个CMD就成了服务派生，无服务身份。还有MSN弹出的邮件或者Space都是作为某个服务的派生的，所以也不是EXPLORER.EXE的子例。）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>debain</title>
      <link>https://shell909090.github.io/blog/archives/168/</link>
      <pubDate>Tue, 31 May 2005 20:54:40 +0800</pubDate>
      
      <guid>https://shell909090.github.io/blog/archives/168/</guid>
      <description>&lt;p&gt;根据babylon的结果，没有debian这个词。根据我的拼音加加的结果，debian打出来是“得便”的意思。而事实上……debian是一个linux的版本。&lt;/p&gt;

&lt;p&gt;不过我很奇怪了，why所有的linux发行版本都这么大呢？windows2000的发行版本是4in1，四个版本合一张光盘。而RedHat9的发行版本是1in3，一个版本放了三张光盘……这个居然还好意思号称内核精简。windows的内核严格说起来也只有2M而已，smss大约100K，Csrss不知道多大，加上NTDLL.user32.Kernel32.win32k.gdi32也没有多大。不过windows组件模型比较大，搞得整个windows貌似比较庞大而已。一般来说，优化过后服务器上大约需要2-3G的分区空间。而一个正常可以跑的linux桌面大致也需要这么多的空间……界面和通用性上还不及。这厢真是郁闷大了。&lt;/p&gt;

&lt;p&gt;不过仔细想想，linux和windows的传奇都貌似到了顶点。windows自从2003后就基本没有了声音，就算现在他出什么新版本我会不会买账还是回事情。（2003现在都没有试过呢……）linux出新版本总比windows落后一步，usb如此，摄像头亦如此。加上PDA或者智能手机一类的嵌入设备中越来越多的使用WinCE（就是PPC啦），ActiveSync和windows捆绑的迹象越发严重。linux的路不好走啊。&lt;/p&gt;

&lt;p&gt;下面恐怕就是分布式系统了吧，如同我前面所讲。分布式系统相对正常系统具备极大的优势。例如硬盘空间共享，这样利用效率就会上升。软件的安装和维护集成，节约成本。CPU资源共用，有利于承担突发事件，并且方便利用用户使用不了的CPU时间。（例如一个在看网页的人的空闲CPU可以分配给运行大型程序的）不过最大的问题就是保密性、可维护性和网络速度问题。一般来说只有当网络速度和硬盘读写速度量级相当的时候才可以考虑分布系统。目前的接入普遍都不快，只有内部网络貌似可以达到这个级别。100Mbps=12.8MB/s，硬盘大约是30MB/s-60MB/s。尚可以考虑考虑。&lt;/p&gt;

&lt;p&gt;分布系统的话首先应当选择微内核，否则不同的机器跑不同的内核岂不乱套。网络部分可能会编译到内核里面来加速。不过最大的问题就是，进程如何跨越机器？如果进程无法跨越机器，那么分布系统啥意思都没有了，干脆上一个DFS算了。如果进程要跨越机器，那么操作台占有，信号，等待，互斥等等就都成了问题。以前可能不明显的互斥问题在网络上就会产生明显效应，不同的互斥算法造成的效率差异会非常显著。&lt;/p&gt;

&lt;p&gt;我设想分布系统可能如此实现。网络和文件系统编译入内核来加速。程序的运行都要在中央服务器上启动才行。每个进程会派生出控制端的概念，控制端对应不同的权限。严格来说，控制端是一个亚进程的概念。因为同样一个程序可能又多个机器要运行，例如IE一类的浏览器。如果放出多个进程恐怕太过浪费，但是如果放出一个进程，那么这个进程的权限又不好控制。考虑中是否可以将界面控制部分和程序分立开，成为控制端。控制端具备独立的变量空间和权限环境，对应不同终端上的用户窗口，可以容纳多个线程。或者进一步说，同样代码在不同机器上运行时候，环境理论上应当相同，除了控制端部分的数据应当不同（替换成本地的数据）。这样输出窗口的时候可以输出到不同的窗口上。&lt;/p&gt;

&lt;p&gt;理论上说，每个程序应当只允许运行一个Instance。如果有人运行某个程序，则应当建立程序的私有空间，并且初始化程序，察看是否已经在运行中。如果在运行中则自网络上虚拟映射入整个程序。而后初始化控制端，并且派生出本地线程。由本地线程来运作整个程序。程序对非控制端部分的操作都要进行互斥访问……真麻烦。&lt;/p&gt;

&lt;p&gt;如果某个机器具备空CPU，而另外一个机器CPU运行满，则将整个进程映射入空闲机器中，包括控制端部分。这样可以用空闲的CPU，当然前提必须是支持多线程，这样才可以移动一个线程过去。不过问题是保密性，还有如果空闲的机器也要运行这个程序了怎么办？这样恐怕就要将线程移动回去，然后清空控制端重新初始化。但是空闲的CPU就无法利用了。&lt;/p&gt;

&lt;p&gt;呃……貌似扯的蛮远了，从linux安装失败一直扯到了分布系统……今天就这样吧，郁闷……&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>