<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lua on Shell&#39;s Home</title>
    <link>http://shell909090.org/tags/lua/</link>
    <description>Recent content in Lua on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Fri, 15 Jun 2012 07:19:45 +0800</lastBuildDate>
    <atom:link href="http://shell909090.org/tags/lua/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>快速深入一门语言的几个问题</title>
      <link>http://shell909090.org/blog/archives/2194/</link>
      <pubDate>Fri, 15 Jun 2012 07:19:45 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2194/</guid>
      <description>&lt;div&gt;劳资明天要结婚了，今天婚前最后一个blog。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;1.hello, world&lt;br /&gt;目标：屏幕上打印出hello, world。&lt;br /&gt;原因：不解释。&lt;div&gt;进阶：当命令行给与不同参数的时候，打印hello, 名字。给与开关的时候，打印hello, 123。&lt;br /&gt;&lt;br /&gt;&lt;div&gt;2.正则提取&lt;br /&gt;目标：写一个正则表达式(或者类似的东西)，从一段网页源码中找到某个标签的内容，去掉前后空格，显示。&lt;br /&gt;

原因：测试字符串处理能力。&lt;br /&gt;进阶：支持正则扩展&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;3.扫描排重&lt;br /&gt; 目标：将某个目录和子目录下的所有文件扫描，排除重复的文件。&lt;br /&gt; 原因：测试文件系统操作能力。&lt;/div&gt;&lt;div&gt;进阶：多线程处理，注意吞吐颠簸。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;4.做24点自动计算程序&lt;br /&gt;目标：写一个程序，能够计算24点。要求能够自定义扩展算符。&lt;br /&gt;原因：检查深度优先搜索，栈，结构设计，抽象处理能力等等。&lt;/div&gt;&lt;div&gt;进阶：做并发处理。有数种语言可能无法实现并发，或并发实现难度大，不美观，例如python。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;5.做一个计算器&lt;br /&gt;

 目标：做一个计算器，要求能计算1+2*3=7，并支持()。&lt;br /&gt;原因：表达式解析和处理需要用到程序的方方面面，字符串处理等等。&lt;/div&gt;&lt;div&gt;进阶：做一个本语言的eval函数出来。&lt;/div&gt;&lt;div&gt;&lt;br /&gt; &lt;/div&gt;&lt;div&gt;7.抓网页&lt;br /&gt;目标：实现一个服务，定期下载符合规则的一批网页，解析，获得格式化的数据，并存入数据库。&lt;/div&gt;&lt;div&gt;原因：测试系统开发能力，基础网络库，字符串处理能力。&lt;/div&gt;&lt;div&gt;进阶：分布化抓取。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;8.留言板&lt;br /&gt;目标：设计一个留言板，将所有人提交的话保存起来，能一并展示。提交不需验证，展示不需分页。&lt;br /&gt;原因：测试网络服务能力，数据库支持和多国语言支持。&lt;br /&gt;

 &lt;/div&gt;&lt;/div&gt;&lt;div&gt;进阶：防止XSS攻击。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;9.异步大并发服务器&lt;/div&gt;&lt;div&gt;目标：设计一个异步http服务器，能对请求做出响应，添加，删除，修改数据库中的数据。不得使用现有的http框架和容器。&lt;/div&gt;&lt;div&gt;原因：集成性测试&lt;/div&gt;&lt;div&gt;进阶：不使用现有数据库，自己写一个。。。&lt;/div&gt; &lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>语言的效率差异2</title>
      <link>http://shell909090.org/blog/archives/2174/</link>
      <pubDate>Fri, 18 May 2012 07:14:24 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2174/</guid>
      <description>&lt;div&gt;# 问题 #&lt;/div&gt;&lt;div&gt;为了更深入的测试语言，我做了一个经典问题——24点。&lt;/div&gt;&lt;div&gt;这个问题主要是测试递归，循环效率，还有数组和树的复制性能。&lt;/div&gt;&lt;div&gt;为了简化问题，方便测试，我的问题是这样描述的：&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;gt; 有一个数组，里面有多个正整数。有一个操作数组，其中每个都是双目操作符。找出以两者构成算式，其值等于给定值的所有表达式组合。&lt;/div&gt;&lt;div&gt;

&amp;gt; 要求不得遗漏，可以有少量重复。例如可交换算符的交换同构暂不做排重。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;实际运行的时候，取+-*/和3 4 6 8，运行100次，查看时间消耗。正确的单次输出结果应当是这样的。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;gt; (((8 + 4) / 3) * 6) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; (6 / (3 / (8 + 4))) = 24&lt;/div&gt;&lt;div&gt;

&amp;gt; (((8 + 4) * 6) / 3) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; (((8 / 4) + 6) * 3) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; (((8 - 6) * 3) * 4) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; (((8 - 6) * 4) * 3) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; (((3 * 4) - 8) * 6) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; ((8 - (6 / 3)) * 4) = 24&lt;/div&gt;

&lt;div&gt;&amp;gt; (((4 + 8) / 3) * 6) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; (6 / (3 / (4 + 8))) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; (((4 + 8) * 6) / 3) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; (((8 / 4) + 6) * 3) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; (((4 * 3) - 8) * 6) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; (((8 - 6) * 3) * 4) = 24&lt;/div&gt;

&lt;div&gt;&amp;gt; (((8 - 6) * 4) * 3) = 24&lt;/div&gt;&lt;div&gt;&amp;gt; ((8 - (6 / 3)) * 4) = 24&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# python #&lt;/div&gt;&lt;div&gt;python的解很复杂，长达31行，以下是我写的解。当然，还有更简单的版本，我可以用eval来干这个事情，代码只有24行，但是确实给人很evil的感觉。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;from itertools import combinations&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;class opt(object):&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;    def __init__(self, name, func, ex=True):&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;        &lt;a href=&#34;http://self.name&#34;&gt;self.name&lt;/a&gt;, self.func, self.exchangable = name, func, ex&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;    def __str__(self): return &lt;a href=&#34;http://self.name&#34;&gt;self.name&lt;/a&gt;&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;    def __call__(self, l, r): return self.func(l, r)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    def fmt(self, l, r):&lt;/div&gt; &lt;div&gt; &lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;        return &amp;#39;(%s %s %s)&amp;#39; % (fmt_exp(l), str(self), fmt_exp(r))&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;def eval_exp(e):&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;    if not isinstance(e, tuple): return e&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;    try: return e[0](eval_exp(e[1]), eval_exp(e[2]))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;    except: return None&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;def fmt_exp(e): return e[0].fmt(e[1], e[2]) if isinstance(e, tuple) else str(e)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;def print_exp(e): print fmt_exp(e), eval_exp(e)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;def chkexp(target):&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;    def do_exp(e):&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;        if abs(eval_exp(e) - target) &amp;lt; 0.001: print fmt_exp(e), &amp;#39;=&amp;#39;, target&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;    return do_exp&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;def iter_all_exp(f, ops, ns, e=None):&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;    if not ns: return f(e)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;    for r in set(ns):&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;        ns.remove(r)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;        if e is None: iter_all_exp(f, ops, ns, r)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;        else:&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;            for op in ops:&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;                iter_all_exp(f, ops, ns, (op, e, r))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;                if not op.exchangable:&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;                    iter_all_exp(f, ops, ns, (op, r, e))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;        ns.append(r)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;opts = [&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    opt(&amp;#39;+&amp;#39;, lambda x, y: x+y),&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;    opt(&amp;#39;-&amp;#39;, lambda x, y: x-y, False),&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;    opt(&amp;#39;*&amp;#39;, lambda x, y: x*y),&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;    opt(&amp;#39;/&amp;#39;, lambda x, y: float(x)/y, False),]&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;if __name__ == &amp;#39;__main__&amp;#39;:&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;    for i in xrange(100): iter_all_exp(chkexp(24), opts, [3, 4, 6, 8])&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;以下是100次的时间：&lt;/div&gt;&lt;div&gt;&amp;gt; real&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;0m2.259s&lt;/div&gt;

&lt;div&gt;&amp;gt; user&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;0m2.248s&lt;/div&gt;&lt;div&gt;&amp;gt; sys&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;0m0.004s&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# common lisp #&lt;/div&gt;&lt;div&gt;

lisp来解这个问题简直是作弊，难怪被叫做人工智能语言。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;(defun chkexp (target)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;  (lambda (e)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;    (if (equal (ignore-errors (eval e)) target) (print e))))&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;(defun exchangeable (op)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;  (not (member op &amp;#39;(- /))))&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;(defun iter-all-exp (f ops ns &amp;amp;optional e)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;  (cond&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;    ((not ns) (funcall f e))&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;    ((not e) (dolist (r (remove-duplicates ns))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;       (iter-all-exp f ops (remove r ns :count 1) r)))&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;    (t (dolist (r (remove-duplicates ns))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt; (let ((nss (remove r ns :count 1)))&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;     &lt;/span&gt;   (dolist (op ops)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;     (iter-all-exp f ops nss `(,op ,e ,r))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;     (if (not (exchangeable op))&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;         &lt;/span&gt; (iter-all-exp f ops nss `(,op ,r ,e)))))))))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;(iter-all-exp (chkexp 24) `(+ - * /) `(3 4 6 8))&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;只有短短17行。原因在于，lisp本身的ast即是用数据结构表示的，因此根本不需要我做eval函数，也不需要画蛇添足的弄自定义算符，直接用系统算符上。显示，打印，都是现成的。需要写的只有主体逻辑。结果也很特别：&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;gt; (* (- (* 3 4) 8) 6) &lt;/div&gt;&lt;div&gt;&amp;gt; (* (- 8 (/ 6 3)) 4) &lt;/div&gt;&lt;div&gt;&amp;gt; (* (- (* 4 3) 8) 6) &lt;/div&gt;&lt;div&gt;&amp;gt; (* (/ (+ 4 8) 3) 6) &lt;/div&gt;&lt;div&gt;&amp;gt; (/ 6 (/ 3 (+ 4 8))) &lt;/div&gt;&lt;div&gt;&amp;gt; (/ (* (+ 4 8) 6) 3) &lt;/div&gt;

&lt;div&gt;&amp;gt; (* (+ (/ 8 4) 6) 3) &lt;/div&gt;&lt;div&gt;&amp;gt; (* (- 8 (/ 6 3)) 4) &lt;/div&gt;&lt;div&gt;&amp;gt; (* (* (- 8 6) 3) 4) &lt;/div&gt;&lt;div&gt;&amp;gt; (* (* (- 8 6) 4) 3) &lt;/div&gt;&lt;div&gt;&amp;gt; (* (/ (+ 8 4) 3) 6) &lt;/div&gt;&lt;div&gt;&amp;gt; (/ 6 (/ 3 (+ 8 4))) &lt;/div&gt;&lt;div&gt;

&amp;gt; (/ (* (+ 8 4) 6) 3) &lt;/div&gt;&lt;div&gt;&amp;gt; (* (+ (/ 8 4) 6) 3) &lt;/div&gt;&lt;div&gt;&amp;gt; (* (* (- 8 6) 3) 4) &lt;/div&gt;&lt;div&gt;&amp;gt; (* (* (- 8 6) 4) 3) &lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;不但行数只有一半，速度也很让人吐血，比python快了近一倍，这是100次的结果。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;Evaluation took:&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  1.379 seconds of real time&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  1.372086 seconds of total run time (1.372086 user, 0.000000 system)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;  [ Run times consist of 0.012 seconds GC time, and 1.361 seconds non-GC time. ]&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  99.49% CPU&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;  3,628,800 forms interpreted&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;  4,127,047,350 processor cycles&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  102,577,080 bytes consed&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# go #&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# lua #&lt;/div&gt;&lt;div&gt;lua的代码是所有语言中最罗嗦的，足足长达60行，超过python许多。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;function find_item(tbl, obj)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   for i, v in pairs(tbl) do&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      if v == obj then return i end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   end&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   return nil&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;function remove_duplicates (tbl)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   local newtbl = {}&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   for i, v in pairs(tbl) do&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      if find_item(newtbl, v) == nil then&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt; table.insert(newtbl, v)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;   end&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   return newtbl&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;function fmt_exp (e)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   if type(e) ~= &amp;#39;table&amp;#39; then&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;      return tostring(e)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   else&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;      return &amp;#39;(&amp;#39; .. fmt_exp(e[3]) .. e[1] .. fmt_exp(e[4]) .. &amp;#39;)&amp;#39;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;   end&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;function eval_exp (e)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;   if type(e) ~= &amp;#39;table&amp;#39; then&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;      return tonumber(e)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   else&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;      return e[2](eval_exp(e[3]), eval_exp(e[4]))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;function chkexp (target)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   return function (e)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;       &lt;/span&gt;     if eval_exp(e) == target then&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;           &lt;/span&gt;print(fmt_exp(e))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;     end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;     &lt;/span&gt;  end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;end&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;function iter_all_exp (f, ops, ns, e)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;   if table.maxn(ns) == 0 then return f(e) end&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   for i, r in pairs(remove_duplicates(ns)) do&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;      table.remove(ns, find_item(ns, r))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;      if e == nil then&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;       &lt;/span&gt; iter_all_exp(f, ops, ns, r)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      else&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt; for op, fp in pairs(ops) do&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;     &lt;/span&gt;    iter_all_exp(f, ops, ns, {op, fp, e, r})&lt;/div&gt;&lt;div&gt;

&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;       &lt;/span&gt;    if find_item(exchangable, op) == nil then&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;        &lt;/span&gt;       iter_all_exp(f, ops, ns, {op, fp, r, e})&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;    end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt; end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;      end&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;      table.insert(ns, r)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;   end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;end&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;exchangable = {&amp;#39;+&amp;#39;, &amp;#39;*&amp;#39;}&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;opts = {&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   [&amp;#39;+&amp;#39;] = function (a, b) return a + b end,&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   [&amp;#39;-&amp;#39;] = function (a, b) return a - b end,&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;   [&amp;#39;*&amp;#39;] = function (a, b) return a * b end,&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   [&amp;#39;/&amp;#39;] = function (a, b) return a / b end,&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;}&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;iter_all_exp(chkexp(24), opts, {3, 4, 6, 8})&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;其实lua的代码很好看，自然语言风格，语言写出来后都能看懂。然而lua秉持了最小化内核的方针，死活不提供一些很常用的函数。我上来近15行全在写常用函数，查找某个值在表中的位置，还有除去表中的重复元素。实现下来，效率也不是特别高，基本和python相当。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;gt; real&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;0m2.222s&lt;/div&gt;

&lt;div&gt;&amp;gt; user&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;0m2.184s&lt;/div&gt;&lt;div&gt;&amp;gt; sys&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;0m0.000s&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>语言的效率差异1</title>
      <link>http://shell909090.org/blog/archives/2172/</link>
      <pubDate>Mon, 14 May 2012 02:52:27 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2172/</guid>
      <description>&lt;div&gt;# 问题 #&lt;/div&gt;&lt;div&gt;为了测试语言的效率，做一个正则解析。&lt;/div&gt;&lt;div&gt;预先说好，正则解析的问题是老板正在做的一个实际问题，我把其他和效率无关的部分去了。因此我接受“用法不正确”这样的反驳理由，但是不接受“这不是典型用例”的理由。我欢迎你指正我的用法错误，或者对语言不了解导致的效率低下，但是别来和我吵吵这种例子太特殊。另外，在调整代码和评估速度的时候，顺便注意一下代码行数。我知道用汇编逐行写和优化会很优秀，但是这对实际工作基本没有帮助。&lt;/div&gt;

&lt;div&gt;问题是这样的：&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;gt; 有一个文本文件，每行两个数，要求解析出来这两个数。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;我用python生成了数据，代码是这样的&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;    with open(sys.argv[1], &amp;#39;w&amp;#39;) as fo:&lt;/div&gt;&lt;div&gt;        for i in xrange(500000):&lt;/div&gt;

&lt;div&gt;            fo.write(&amp;#39;%d %dn&amp;#39; % (i, random.randint(0, 10000)))&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;正则分析速率，是个典型的CPU密集操作。对于非编译型语言而言(这里的编译是指正则表达式的解析预编译，实际上除了lisp还真没有编译型的，即使是go也是现场拿到正则进行解析的)，这主要是看正则库的实现效率。很多时候，语言的效率问题并不取决于语言本身，还取决于语言的库的实现。大部分情况下我们都不可能砍掉系统的库重新来一个，那还不如换一门语言。&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# python #&lt;/div&gt;&lt;div&gt;我首先贴出python语言的解答。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;reline = re.compile(&amp;#39;(d+) (d+)&amp;#39;)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;def main():&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;with open(sys.argv[1], &amp;#39;r&amp;#39;) as fi:&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;           &lt;/span&gt;for line in fi: reline.match(line).groups()&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;这是性能&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;gt; real    0m0.466s&lt;/div&gt;&lt;div&gt;&amp;gt; user    0m0.436s&lt;/div&gt;&lt;div&gt;&amp;gt; sys     0m0.012s&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# common lisp #&lt;/div&gt;&lt;div&gt;我找了N个正则包，实际能用的只有ppcre。有些包号称很快，实际测试下来还不如ppcre。&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;(require :cl-ppcre)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;(defun grepfile (filename)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;  (let* ((cl-ppcre:*use-bmh-matchers* t)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt; (cl-ppcre:*regex-char-code-limit* 256)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt; (scanner (cl-ppcre:create-scanner &amp;quot;d+ d+&amp;quot;)))&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;    (with-open-file (in filename)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;      (loop for line = (read-line in nil) while line do&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;   (cl-ppcre:split scanner line)))&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;  ))&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;代码在slime里面测试(time (grepfile &amp;quot;data.dat&amp;quot;))，下面是结果&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;CL-USER&amp;gt; (time (main))&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;Evaluation took:&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  0.398 seconds of real time&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;  0.392025 seconds of total run time (0.384024 user, 0.008001 system)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;  [ Run times consist of 0.016 seconds GC time, and 0.377 seconds non-GC time. ]&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;  98.49% CPU&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  1,188,481,425 processor cycles&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;  72,242,256 bytes consed&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# go #&lt;/div&gt;&lt;div&gt;go的代码是现学现卖的，不知道是不是哪里写出问题了。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;func main() {&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;        &lt;/span&gt;f, _ := os.Open(&amp;quot;data.txt&amp;quot;)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;r := bufio.NewReader(f)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;     &lt;/span&gt;rex, _ := regexp.Compile(&amp;quot;(d+) (d+)&amp;quot;)&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;     &lt;/span&gt;for line, isPrefix, err := r.ReadLine();&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;     &lt;/span&gt;    err == nil &amp;amp;&amp;amp; !isPrefix;&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;      &lt;/span&gt;    line, isPrefix, err = r.ReadLine() {&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;         &lt;/span&gt;rex.FindSubmatch(line)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;       &lt;/span&gt;}&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;}&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;结果居然要差一个数量级！&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;gt; real&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;0m8.699s&lt;/div&gt;&lt;div&gt; &amp;gt; user&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;0m8.593s&lt;/div&gt; &lt;div&gt;&amp;gt; sys&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;0m0.036s&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;这太出乎我的意料了。google的v8引擎赫赫有名，我猜想也应当用到了go上面才是，怎么会性能差成这样？gary说过正则在他那里很快，我希望是我用错了。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# lua #&lt;/div&gt;

&lt;div&gt;lua没有使用正则包，更准确的说，lua内置的字符串处理函数可以处理这个情况。以下是我的代码：&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;for line in io.lines(&amp;quot;data.txt&amp;quot;) do&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;   for w in string.gmatch(line, &amp;quot;%d+&amp;quot;) do&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;      -- print(w)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;   end&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;end&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;以下是执行结果：&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;gt; real&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;0m0.796s&lt;/div&gt;&lt;div&gt;&amp;gt; user&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;0m0.792s&lt;/div&gt;

&lt;div&gt;&amp;gt; sys&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;0m0.000s&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;lua的代码的却很好看，但是效率上却不见得高。这是当然的，gmatch可是每工作一次就要解析一次阿。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;# lua-rex-pcre #&lt;/div&gt;&lt;div&gt;装一个支持pcre的正则包，lua-rex-pcre。&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;r = require &amp;quot;rex_pcre&amp;quot;.new(&amp;quot;(d+) (d+)&amp;quot;, 0)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;   &lt;/span&gt;for line in io.lines(&amp;quot;data.txt&amp;quot;) do&lt;/div&gt;

&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;   r.match(r, line)&lt;/div&gt;&lt;div&gt;&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;  &lt;/span&gt;end&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;OK，速度一下就快了不少：&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt; &lt;div&gt; &amp;gt; real&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;0m0.643s&lt;/div&gt;&lt;div&gt;&amp;gt; user&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt;    &lt;/span&gt;0m0.632s&lt;/div&gt;&lt;div&gt;&amp;gt; sys&lt;span class=&#34;Apple-tab-span&#34; style=&#34;white-space:pre&#34;&gt; &lt;/span&gt;0m0.008s&lt;/div&gt;

&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>