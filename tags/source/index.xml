<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Source on Shell&#39;s Home</title>
    <link>http://shell909090.org/tags/source/</link>
    <description>Recent content in Source on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Mon, 19 Dec 2011 16:08:11 +0800</lastBuildDate>
    <atom:link href="http://shell909090.org/tags/source/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>linux tty部分源码阅读</title>
      <link>http://shell909090.org/blog/archives/2020/</link>
      <pubDate>Mon, 19 Dec 2011 16:08:11 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2020/</guid>
      <description>

&lt;h1 id=&#34;1-事情从file开始&#34;&gt;1.事情从file开始&lt;/h1&gt;

&lt;div&gt;

   
file的定义在include/linux/fs.h中，其中有两个field，一个叫file\_operations
\*f\_op，一个叫void
\*private\_data。file\_operations定义了所有file能够进行的操作，在tty这个层面而言，drivers/tty/tty\_io.c能看到有个叫做file\_operations
tty\_fops的东西，下面有个叫console\_fops的东西。两者区别不大，就是write函数进行了一下包装而已。从这里可以看出，系统将某个file的读写操作，转包给了tty\_io.c这个文件。这个转包的手法非常类似虚函数。如果将tty\_io.c里面的函数看作一个类的所有成员，那么tty\_fops就是虚函数表，而f\_op就是虚函数指针\_v\_ptr。

&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-tty-io的二转包&#34;&gt;2.tty_io的二转包&lt;/h1&gt;

&lt;div&gt;

   
tty\_io做了什么？他直接转包给了ldisc来处理这个事情。从tty\_struct的结构我们能够看到，有这么一个field，tty\_ldisc
\*ldisc。而tty\_ldisc.h文件里面，我们能看到这个结构又有这么一个成员，tty\_ldisc\_ops
\*ops。同样手法，第二次使用。目标是tty/下面很多n\_开始的文件，例如n\_gsm，估计是处理手机的。我们的目标看起来像是n\_tty.c中的tty\_ldisc\_ops
tty\_ldisc\_N\_TTY对象。

&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;3-n-tty做了些什么&#34;&gt;3.n_tty做了些什么&lt;/h1&gt;

&lt;div&gt;

   
n\_tty也做了很多转包，例如对于n\_tty\_write而言，他使用了tty-&amp;gt;ops-&amp;gt;write这个函数。我们从struct
tty\_struct中可以看到这个field，tty\_operations
\*ops。目标是谁？看起来像是pty.c，他里面有很多定义，例如tty\_operations
master\_pty\_ops\_bsd，tty\_operations
slave\_pty\_ops\_bsd，tty\_operations ptm\_unix98\_ops，tty\_operations
pty\_unix98\_ops。

&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;4-pty总不转包了吧&#34;&gt;4.pty总不转包了吧&lt;/h1&gt;

&lt;div&gt;

   
以write而言，pty.c做的很简单，就是tty\_insert\_flip\_string而已。不过之后调用了tty\_flip\_buffer\_push，这个又会调用flush\_to\_ldisc，这个里面会调用ldisc-&amp;gt;ops。从上文中我们知道，这个函数的实体在n\_tty.c的n\_tty\_receive\_buf。

&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;5-n-tty-receive-buf做了些什么&#34;&gt;5.n_tty_receive_buf做了些什么&lt;/h1&gt;

&lt;div&gt;

   
这个函数对每个字符依次处理，如果是普通字符，就调用n\_tty\_receive\_char。这个函数会调用put\_tty\_queue，经过两次转手，最终，这个字符进入了read\_buf。这是一个循环队列。

&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>