<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Memory Leak on Shell&#39;s Home</title>
    <link>http://shell909090.org/tags/memory-leak/</link>
    <description>Recent content in Memory Leak on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Thu, 31 Jan 2008 19:21:06 +0800</lastBuildDate>
    <atom:link href="http://shell909090.org/tags/memory-leak/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Process Explorer的潜在内存泄漏</title>
      <link>http://shell909090.org/blog/archives/426/</link>
      <pubDate>Thu, 31 Jan 2008 19:21:06 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/426/</guid>
      <description>&lt;p&gt;&lt;p&gt;    贝壳最近碰到一个郁闷到死的问题。机器经常出现硬盘狂转，系统响应延迟。系统弹出一个错误，然后死机。贝壳开始猜测是硬盘驱动问题，升级驱动N次，无效。然后再猜测是ext2fs的问题(贝壳用这个驱动挂载linux下面的盘的)，看来看去，不是。最后，贝壳确定了，这是内存泄漏了～～～&lt;br /&gt;    问题是，这时候可没人跳出来推荐喝什么口服液的。贝壳系统中永远挂着一个procexp，看内存状态的。这东西是sysinternals的产品，后来被微软收购了。功能强大，很多系统调试，杀马都需要用到。于是贝壳就用这个工具看哪个程序的内存泄漏，可是看来看去看不到。准确说，是没等贝壳看到，系统就先死透了。最后贝壳多次尝试，发现了一个死机的规律。当mysql开启的时候，procexp就会随时发生异常死机。这是一个重要的提示，要么mysql内存泄漏了，要么procexp内存泄漏了。究竟是哪个呢？贝壳用了同属于sysinternals开发的pstools系列工具，仔细检查了异常发生时候的内存状态，确定，Process Explorer存在内存泄漏的风险！&lt;br /&gt;    看来sysinternals被微软收购后，旗下的工具也出现了微软的一贯特色。以下是一次内存泄漏后，终止mysql服务后抓下来的内存状态输出。如果不终止mysql，不等我抓系统就挂了。&lt;br /&gt;Process memory detail for HOME-B2326348D0:
&lt;p&gt;Name                Pid      VM      WS    Priv Priv Pk   Faults   NonP Page&lt;br /&gt;Idle                  0       0      28       0       0        0      0    0&lt;br /&gt;System                4     800      52       0       0    10120      0    0&lt;br /&gt;smss                772    3748      48     172    1648      223      0    5&lt;br /&gt;csrss               828   68132    1464    2304    3768    13748      6  144&lt;br /&gt;winlogon            856   61528     580    8536    8684     5143     39   96&lt;br /&gt;services            900   37724     804    2256    2404     2740      7   65&lt;br /&gt;lsass               912   44848     352    2684    2860     7332      7   80&lt;br /&gt;svchost            1060   36904     200    1500    1544     1028      3   68&lt;br /&gt;svchost            1136   39256     456    1984    2004     1437     13   72&lt;br /&gt;svchost            1216  118756    2564   19236   28112    24221     93  197&lt;br /&gt;svchost            1292   31728     192    1472    1512     1123      4   55&lt;br /&gt;aswUpdSv           1536   18748      52     652     652      557      2   31&lt;br /&gt;ashServ            1592  120428    6704   16628   41168  1076043      8  128&lt;br /&gt;explorer           1884  119644    1908   19128   20552  4364782     16  177&lt;br /&gt;spoolsv             288   50072     224    3564    3828     1502      5   85&lt;br /&gt;TSVNCache           544   48008     700    6968    7068    21580      4   67&lt;br /&gt;mobmeter            620   41116     588    4940    5044    14266      3   63&lt;br /&gt;procexp             628  605756   15532  549068  549068  4776417      8  109&lt;br /&gt;ashDisp             636   54468     928    6992    7016    28399      5   80&lt;br /&gt;ctfmon              664   39064     380    4816    4840    15588      4   66&lt;br /&gt;googletalk          720   76420    2852    8540    9036   428030     13  108&lt;br /&gt;mdm                 832   30008     440    1088    1100      860      3   49&lt;br /&gt;svchost            1244   40704     208    2640    2708     1896      3   73&lt;br /&gt;svnserve           1264   16612     124     904     920      652      3   29&lt;br /&gt;svchost             232   37936     536    1592    1636     1330      4   70&lt;br /&gt;alg                 600   35664     200    1312    1352     1018      5   69&lt;br /&gt;TTPlayer           3208   65672    3688   10920   13924   169533      8   86&lt;br /&gt;thunderbird        3240  109016    2272   28832   31344    64167     14  112&lt;br /&gt;conime             3284   42564     404    5184    5184    17612      3   68&lt;br /&gt;firefox            1944  270920   11108  118720  132648  1233696     14  135&lt;br /&gt;flashget           2836  108756   11248   19472   29636   117115     30  146&lt;br /&gt;pyintau            2080   45004     172    4720    4788     1848      3   62&lt;br /&gt;wuauclt            1068   67012     396    6580    6600     2167      7  115&lt;br /&gt;cmd                3540   32764     920    3308    3372    15075      2   60&lt;br /&gt;pslist             3048   32124    3108    2440    2956    10890      2   49&lt;br /&gt;    我们可以看到，procexp这个进程的虚拟内存空间只有60M，工作集更只有15M，可私有内存高达549M！贝壳的机器只有768M内存，不死机还等啥？&lt;br /&gt;    贝壳试验了mysql5.0.45，mysql5.0.51a，mysql5.1.22，procexp11.01，procexp11.04。确定在贝壳的本本上全都会造成上述问题。但是同样的环境在家里的2G内存机器上模拟的时候，全都不出现上述问题。从测试角度讲，这个属于和环境相关的隐性危险，严重级别是重。
&lt;div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>内存泄露检测简说</title>
      <link>http://shell909090.org/blog/archives/359/</link>
      <pubDate>Wed, 07 Feb 2007 22:48:13 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/359/</guid>
      <description>&lt;p&gt;我们首先从一段代码说起。&lt;br /&gt;#define _CRTDBG_MAP_ALLOC&lt;br /&gt;#include &lt;br /&gt;#include &lt;br /&gt;class           test {&lt;br /&gt;  public:&lt;br /&gt;    test () {&lt;br /&gt;        lpBuffer = new char[0x1000];&lt;br /&gt;    };&lt;br /&gt;    ~test () {&lt;br /&gt;        delete          lpBuffer;&lt;br /&gt;    };&lt;br /&gt;    void           *operator  new (size_t s) {&lt;br /&gt;        return malloc (s);&lt;br /&gt;    };&lt;br /&gt;    void operator   delete (void *pvMem) {&lt;br /&gt;        if (pvMem != NULL)&lt;br /&gt;            free (pvMem);&lt;br /&gt;    };&lt;br /&gt;    void           *operator  new[] (size_t s) {&lt;br /&gt;        return malloc (s);&lt;br /&gt;    };&lt;br /&gt;    void operator   delete[] (void *pvMem) {&lt;br /&gt;        if (pvMem != NULL)&lt;br /&gt;            free (pvMem);&lt;br /&gt;    };&lt;br /&gt;    char           *lpBuffer;&lt;br /&gt;};&lt;br /&gt;test &amp;amp; tt ()&lt;br /&gt;{&lt;br /&gt;    static test     t;&lt;br /&gt;    return t;&lt;br /&gt;}&lt;br /&gt;//test t;&lt;br /&gt;void process ()&lt;br /&gt;{&lt;br /&gt;    test            tf;&lt;br /&gt;//  _CrtDumpMemoryLeaks ();&lt;br /&gt;}&lt;br /&gt;int _tmain (int argc, _TCHAR * argv[])&lt;br /&gt;{&lt;br /&gt;//  test tf;&lt;br /&gt;    test* tp=new test();&lt;br /&gt;    _CrtSetReportMode (_CRT_WARN, _CRTDBG_MODE_FILE);&lt;br /&gt;    _CrtSetReportFile (_CRT_WARN, _CRTDBG_FILE_STDERR);&lt;br /&gt;    _CrtSetDbgFlag (_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);&lt;br /&gt;    process ();&lt;br /&gt;//  printf(&amp;quot;hello, world.n&amp;quot;, t.lpBuffer);&lt;br /&gt;    printf (&amp;quot;hello, world.n&amp;quot;, tt ().lpBuffer);&lt;br /&gt;//    _CrtDumpMemoryLeaks ();&lt;br /&gt;//  printf(&amp;quot;hello, world.n&amp;quot;, t.lpBuffer);&lt;br /&gt;    return 0;&lt;br /&gt;}&lt;br /&gt;    以上代码，大家可以分别注释不同位置，来查看不同效果。不过我们还是从最基础的如何检测开始说起吧。&lt;br /&gt;    首先在头中引入。&lt;br /&gt;#define _CRTDBG_MAP_ALLOC&lt;br /&gt;#include &lt;br /&gt;#include &lt;br /&gt;    在引入后，程序结束的时候调用_CrtDumpMemoryLeaks ();就可以打印出来内存泄露的情况。不过有几个问题，首先，打印出来的位置是在调试中。也就是说，如果不使用调试信息查看工具，是看不到信息的。这个问题不难解决。我们可以在程序开始的时候设定。&lt;br /&gt;    _CrtSetReportMode (_CRT_WARN, _CRTDBG_MODE_FILE);&lt;br /&gt;    _CrtSetReportFile (_CRT_WARN, _CRTDBG_FILE_STDERR);&lt;br /&gt;    将出错信息打印到Console输出中。当然如果程序是BCB或者是MFC，也大可打印到文件中。&lt;br /&gt;    其次，打印出来的出错信息可能是这样的。&lt;br /&gt;Detected memory leaks!&lt;br /&gt;Dumping objects -&amp;gt;&lt;br /&gt;c:program filesmicrosoft visual studio .net 2003vc7includecrtdbg.h(692) : {44} normal block at 0x00342A28, 4096 bytes long.&lt;br /&gt; Data: &amp;lt;                &amp;gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD&lt;br /&gt;Object dump complete.&lt;br /&gt;    很好用没错，不过为什么文件上面写的是crtdbg.h呢？其实这个是crtdbg.h所插入的operator new，用来创建内存区域的。malloc在其中被调用，因此所有用new的地方出现的泄露都会是这个位置。&lt;br /&gt;    解决这个问题稍微有些烦琐，需要持续的将operator new重载出来。&lt;br /&gt;    void           *operator  new (size_t s) {&lt;br /&gt;        return malloc (s);&lt;br /&gt;    };&lt;br /&gt;    void operator   delete (void *pvMem) {&lt;br /&gt;        if (pvMem != NULL)&lt;br /&gt;            free (pvMem);&lt;br /&gt;    };&lt;br /&gt;    void           *operator  new[] (size_t s) {&lt;br /&gt;        return malloc (s);&lt;br /&gt;    };&lt;br /&gt;    void operator   delete[] (void *pvMem) {&lt;br /&gt;        if (pvMem != NULL)&lt;br /&gt;            free (pvMem);&lt;br /&gt;    };&lt;br /&gt;    当然，理论上我们可以使用多继承，简单的使得某个类具备这个特性。不过遗憾的是多继承往往容易出错，不如手写安全。其次是如果对象并不构建在堆中(更准确的表述是没有使用malloc来分配空间)，那么就不会调用operator new。当然，这时候多数情况下都是栈对象和临时对象，会被系统自动析构。这样我们一般可以得到更好的输出。&lt;br /&gt;Detected memory leaks!&lt;br /&gt;Dumping objects -&amp;gt;&lt;br /&gt;c:program filesmicrosoft visual studio .net 2003vc7includecrtdbg.h(692) : {44} normal block at 0x00342A28, 4096 bytes long.&lt;br /&gt; Data: &amp;lt;                &amp;gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD&lt;br /&gt;d:my documentsvisual studio projectstest_memleaktest_memleak.cpp(18) : {43}normal block at 0x00340FD0, 4 bytes long.&lt;br /&gt; Data: &amp;lt;(*4 &amp;gt; 28 2A 34 00&lt;br /&gt;Object dump complete.&lt;br /&gt;    以上有两个泄露，一个是char test::*lpBuffer;的，另外一个是所分配的空间的。test_memleak.cpp已经被指出了，相信再查不出就是个人水平问题了。(提示，不行可以对operator new下断点)&lt;br /&gt;    最后一个，就是退出的时间。我们在调用_CrtDumpMemoryLeaks ();的时候，会打印出当前没有释放的内存占用。如果在退出时打印，就可以得到泄露的内存。这是抓内存泄露的基础。但是有的时候有多个退出点，这个时候，我们就必须使用如下办法。&lt;br /&gt;    _CrtSetDbgFlag (_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);&lt;br /&gt;    这样会在退出的时候自动调用_CrtDumpMemoryLeaks ();。当然，这个办法也不是万能的。如果程序中出现exit(-1);，那么会打印内存泄露然后退出。如果出现ExitProcess(-1);那就啥都没了。不过这个时候打出来的东西肯定也是废物了。中途退出，没有释放掉东西是正常的很的事情。&lt;br /&gt;    另外两者还有一点区别，当使用_CrtDumpMemoryLeaks ();的时候，我们认为是程序结束了，实际上并没有。在调用exit(-1);的时候其实执行了C/C++的退出步骤，这个在Crt里面有源码的。大致来说有以下几个区别。&lt;br /&gt;    一，main函数中构造对象的析构函数未调用。&lt;br /&gt;    二，全局变量未析构。&lt;br /&gt;    三，局部静态变量未析构。&lt;br /&gt;    很多时候我们在最后打印出来发现有泄露，找半天又找不出。很可能就是以上问题，尤其是第三个问题。&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>