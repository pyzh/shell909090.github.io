<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Windows on Shell&#39;s Home</title>
    <link>http://shell909090.org/tags/windows/</link>
    <description>Recent content in Windows on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Wed, 08 Feb 2012 01:44:01 +0800</lastBuildDate>
    <atom:link href="http://shell909090.org/tags/windows/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>windows下那些好用的免费程序</title>
      <link>http://shell909090.org/blog/archives/2086/</link>
      <pubDate>Wed, 08 Feb 2012 01:44:01 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2086/</guid>
      <description>&lt;p&gt;大部分开源，不开源的特别注明。&lt;/p&gt;

&lt;p&gt;firefox或者chrom替换掉IE。&lt;/p&gt;

&lt;p&gt;不解释了。本公司UED坚持认为在windows下使用IE是一类人格缺陷，有这种缺陷的人应当被自然淘汰。我当然不支持他人格缺陷的论点，我认为是智力缺陷。&lt;/p&gt;

&lt;p&gt;Everything(不开放源码)&lt;/p&gt;

&lt;p&gt;文件搜索工具，肯定要装，平时不消耗资源，需要的时候闪电一般的把你需要的东西找出来。这个东西会彻底的改变你文件管理的习惯。&lt;/p&gt;

&lt;p&gt;klite codec&lt;/p&gt;

&lt;p&gt;还在用腾讯/暴风影音？我推荐klite codec。这个玩意里面内置了Media Player Classic - Home Cinema作为播放器，并且把常用的解码器组件都装上了。基本好用。当然，所谓基本，和商用播放器的一堆花哨功能不同。klite的功能还是略差的，比较偏向基本功能的稳定。不过好在，有的地方klite更强一点——例如没有烦人的广告和插件，性能和稳定性都很不错，而且有些生僻格式也做了支持。实际上，我觉得出问题最多的还是这些生僻格式和wmv。&lt;/p&gt;

&lt;p&gt;mplayer&lt;/p&gt;

&lt;p&gt;比klite还强的播放器，和vlc并称最强播放器之二。就是太难玩了。&lt;/p&gt;

&lt;p&gt;另外，我不推荐在windows下用vlc，不太稳定。&lt;/p&gt;

&lt;p&gt;MediaCoder&lt;/p&gt;

&lt;p&gt;转编码不错，除了rmvb格式外都很好转。压个片给手机的时候很方便。&lt;/p&gt;

&lt;p&gt;putty(英文版!)&lt;/p&gt;

&lt;p&gt;远程命令行工具，基本是做linux开发的不二选择。即使我没事用windows也习惯装个虚拟机，跑个linux，然后用putty连上去。当然，putty肯定是要用英文版的，具体自己google吧，不要baidu。&lt;/p&gt;

&lt;p&gt;foobar2000(不开放源码)&lt;/p&gt;

&lt;p&gt;音乐播放器，替换千千静听和酷狗的。确实是超级强的定制工具，居然支持从zip/7z中加载音乐。这样我下的音乐包都可以直接用了，不用解压。&lt;/p&gt;

&lt;p&gt;launchy&lt;/p&gt;

&lt;p&gt;启动工具。有更好的启动程序可以给我介绍一下，我现在用的是launchy。按热键，敲几个字母，就可以启动程序了。而且这个是linux/windows支持的，两者习惯完全一致。当然，如果你stick在某个系统上，可以找找更适合的软件。&lt;/p&gt;

&lt;p&gt;honeyview(不开放源码)&lt;/p&gt;

&lt;p&gt;漫画工具，主要是还在维护。能用的漫画工具也没几个了，comicviewer不维护了，acdsee根本是个庞然大物。&lt;/p&gt;

&lt;p&gt;peazip&lt;/p&gt;

&lt;p&gt;压缩工具，挺不错的。现在大多数都用winrar了吧？一个是这玩意需要破解，不然就乱弹窗。作为一个程序员，我实在不好意思破解。另一方面，这个东西对samba的支持不好，在win7下，他没法打开samba共享出来的文件，而且某些文件会乱码。peazip可以解压我要用的全部格式，包括rar。并且可以生成我要的大部分格式，包括linux格式，不包括rar。这个主要受限于copyright问题。&lt;/p&gt;

&lt;p&gt;不过peazip对某些比较奇怪的字符支持不如winrar，有时会不认识一些日文压缩包。这个问题对honeyview等程序都存在，我认为是这些压缩包自己的问题。&lt;/p&gt;

&lt;p&gt;Foxit(不开放源码)&lt;/p&gt;

&lt;p&gt;pdf阅读工具，国产软件，比adobe的强。不过细节总是做的不是很好。例如书签不够强大，注记功能不足，不支持zip文件读取等。不过要不用foxit，就要用回adobe，你自己看着办。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>千千静听被百度收购了，WTF</title>
      <link>http://shell909090.org/blog/archives/2082/</link>
      <pubDate>Mon, 06 Feb 2012 03:00:24 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/2082/</guid>
      <description>&lt;p&gt;我挺喜欢千千静听的，这玩意被我调整到习惯和winamp差不多。自从winamp变成一个庞大的怪物以来，我一直用的这个。&lt;/p&gt;

&lt;p&gt;不过在win7上，我一直删除不掉百度插件。每次我请他们出去，他们又会装上。后来我启用了严格的UAC，并蓄意把目标文件夹标记为没有人拥有权限，发现了问题——千千每次启动都查找并试图重装baidu插件。我开始以为是我下载的版本不对，被捆绑了其他组件。然后我去他们官网，下载了一个最新版本。安装的时候，我留意到发行者是baidu online&amp;hellip;。OK，问题看来不是我下载的版本被恶意捆绑，而是原始版本就写入了这个代码。&lt;/p&gt;

&lt;p&gt;用过firefox或者比较正规的软件（包括微软那个IE）的人都可以留心到，在关于页面中，可以看到这个软件使用了哪些开源组件。这个大部分是因为这个库的版权限定要求使用者必须列出库的名称。不过这点在中文软件上就做的比较差，也许是根本不拿授权当回事吧。&lt;/p&gt;

&lt;p&gt;但是，在软件内打入和软件功能无关的其他组件，那是另一回事情。个人认为，一个程序如果在安装包内捆绑插件，让用户选择安装，我还能接受。毕竟很多软件作者也要吃饭，做插件推广是一条路。如果捆绑强制安装，那就有流氓之嫌了。如果捆绑完了不算，还在每次启动的时候都检查插件是否还在，那就是确定无疑的流氓。&lt;/p&gt;

&lt;p&gt;当然，千千的行为比这个更糟糕（我不选择说更流氓）。千千主页上没有任何地方说明千千归属了百度旗下，只有最下方有一条&amp;lt;千千静听联手百度娱乐推出“百度新歌汇”&amp;gt;的新闻,以及最下方有百度软件世界的连接。我也是从UAC的警告中发现，千千的软件包是用winrar打的（不知道是否是正版），而签名则是Baidu。至于选择，软件安装的时候的却有选择，不过即使选择了“不安装百度工具栏”，“不将hao123设为主页”也没用。还是会有一个叫做BaiduMusicCtrl的东西伴生安装进去，每次ttplayer启动时伴生启动的就是这个。说是和音乐有关的东西么，我在IE的插件和系统启动项中都找不到这个东西的影子，不知道是干吗的。千千删除的时候也不会跟随删除，不过可以找到独立的“百度音乐控件”项目，并且手工删除。更神奇的是，我在主页上找不到任何关于此事的说明还不算，连软件的发行授权都没有。没有发行授权，这软件我们用着算怎么回事呢？&lt;/p&gt;

&lt;p&gt;我又安装了一遍千千，找到了软件使用协议“版权归属所有者所有”。这不是TM废话么。&lt;/p&gt;

&lt;p&gt;OK，很多人在我说，中国人不大在意版权，这句话的时候，要我拿出证据。现在就是一个明证。从整个过程中，我感觉到的并不单是恶意捆绑这么个事情，而是对版权和授权的一个漠视：&lt;/p&gt;

&lt;p&gt;1.没问你要不要，总之给你捆绑安装百度音乐控件，每次千千启动时自动启动更新。&lt;/p&gt;

&lt;p&gt;2.被百度买了，页面上什么关联都没写。&lt;/p&gt;

&lt;p&gt;3.关于授权，这个软件什么都没写。（另外，写授权的时候不要写“保留一切权利”，这是句屁话。你最起码得度让使用权，否则发行软件给别人就是故意诱使别人犯罪。千千的“保留知识产权”还是正确的。）因此，不要问我如果你把千千放到你的主页上会如何——这算再发行，合法不合法就看作者定义了——虽然我觉得他自己都不一定觉的出区别。&lt;/p&gt;

&lt;p&gt;现在改用了foobar2000，很满意。这个东西可以接受samba共享系统，并且支持从zip/7z中读取文件。我很多下载的zip音乐包就可以直接使用了。虽然界面简陋很多，不过用起来更顺手。千千还是留给度娘控吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NSIS在64位下安装时无法写入注册表的问题</title>
      <link>http://shell909090.org/blog/archives/1980/</link>
      <pubDate>Mon, 14 Nov 2011 15:54:50 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1980/</guid>
      <description>&lt;p&gt;最近公司碰到一个问题，NSIS在64位下安装时无法写入注册表。&lt;/p&gt;

&lt;p&gt;首先，这个问题不是UAC没有权限的问题，因为我使用administrator安装依然有问题。其次，问题和win2008没关系，只出现在64位上。&lt;/p&gt;

&lt;p&gt;问题在哪里呢？在写入注册表前，SetRegView 64，写入后换回32，问题解决。&lt;/p&gt;

&lt;p&gt;真TMD的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>论不同系统和客户端的证书管理</title>
      <link>http://shell909090.org/blog/archives/1773/</link>
      <pubDate>Wed, 13 Apr 2011 15:54:41 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1773/</guid>
      <description>&lt;p&gt;上面刚说完x509证书链系统，现在我们说说各种系统和客户端下的证书管理吧。理论上说，系统只要保留一份根证书系统，其余的会自动进行计算。但是杯具的是，不同系统的不同应用，使用的是不同的数据库。这导致你的根证书导入之路漫漫而修远。&lt;/p&gt;

&lt;p&gt;windows系统：&lt;/p&gt;

&lt;p&gt;1.系统证书管理&lt;/p&gt;

&lt;p&gt;在运行中输入certmgr.msc，就可以看到证书管理系统了。根证书管理在“受信任的根证书颁发机构-&amp;gt;证书”下面。对证书文件进行查看，导入，然后导入到这个区域，就可以变成根证书了。要吊销一份证书，删除是不行的，因为会自动加回来。加入“不受信任的证书”好像也无效。我找到的比较实用的方法是右击看属性，“停用这个证书的所有目地”。再试试看？证书应当无效了。&lt;/p&gt;

&lt;p&gt;2.firefox&lt;/p&gt;

&lt;p&gt;火狐的证书系统是独立于系统证书的，因此在windows中做的修改对firefox无效。需要到“选项-&amp;gt;高级-&amp;gt;加密-&amp;gt;查看证书”中（windows下在工具菜单下），在“证书机构”选项卡，导入证书，而后启用所有用途，让证书生效。如果要吊销，跑到同一个地方，删除证书，或者编辑，取消所有用途。需要注意的是，当你删除证书后，再次查看证书列表时，证书会回来。但是此时编辑证书，可以看到，所有用途都被取消了。&lt;/p&gt;

&lt;p&gt;3.chrome&lt;/p&gt;

&lt;p&gt;chrome在windows下使用系统证书，因此不要用chrome自身的证书管理系统，直接修改系统证书就可以。&lt;/p&gt;

&lt;p&gt;linux系统(debian)：&lt;/p&gt;

&lt;p&gt;1.系统证书管理&lt;/p&gt;

&lt;p&gt;运行dpkg-reconfigure ca-certificates，会出现让你配置系统证书的界面。这是系统的证书数据库，自动配置的话好像不能添加，只能取消。你反选某个选项后，/etc/ca-certificates.conf中，对应这个选项的行在行首就会出现!。此时系统内就不再认可这份证书。因此推测，如果你需要自己加入一份证书，需要将证书添加到合适位置，编辑/etc/ca-certificates.conf，加入路径，再执行dpkg-reconfigure ca-certificates或者update-ca-certificates进行更新，此时程序会更新/etc/ssl的某些内容，证书就安装上去了。&lt;/p&gt;

&lt;p&gt;2.firefox&lt;/p&gt;

&lt;p&gt;同样是独立于系统的配置，基本操作和windows差不多，不过linux下面“选项”在“编辑”下面。&lt;/p&gt;

&lt;p&gt;3.chrome&lt;/p&gt;

&lt;p&gt;linux下面的chrome可以在“首选项-&amp;gt;高级-&amp;gt;证书管理器”中，选择“授权中心”。导入后修改权限即加入。注意需要使用禁用，而非删除对应证书，来阻止某些证书。&lt;/p&gt;

&lt;p&gt;这里面说的加入证书，基本是加入自己的证书。至于移除，基本说的是cnnic。cnnic证书有什么危害？目前没有。如果你相信中国的互联网是世界上最开放的互联网，那么下面一堆不看也罢。不过，如果你不相信中国政府颁发出的证书，还是移除的好。在系统内保留一个不受信任的根证书，可能受到证书替换钓鱼。简单来说，你访问一个安全网站的时候，这个网站的证书是如何颁发的，你留心过么？在地址栏网站logo那里右击，查看证书，再找到证书链，你就可以看到，这个证书属于谁，是谁颁发的，这样一个链条。想象一下，你在用gmail的时候，心血来潮看了看域名证书，发现颁发者是CNNIC SSL（google的颁发者是Thawte）。很明显，你访问的网站不是真的gmail，而是一个伪装的网站，将你的请求再转到gmail服务器上。这个网站没有gmail的证书，不过用CNNIC签了一个。于是你的所有请求，收到的邮件内容，发出去的内容，全部被公开了。你也不知道这个替换什么时候进行的，由于安全验证可以通过，系统也没有警告你。是不是有种看到日本恐怖片里面，贞子爬出屏幕的感觉？&lt;/p&gt;

&lt;p&gt;当然，这个是一个特例，有点危言耸听。因为对于某些国外CA，证书也是乱发的。基本只要交钱，给一份材料复印件，一样可以通过审查，得到一本CA证书。然而，这种证书通常比较容易被发现，CA也会很快吊销这些证书。如果不是这样，这些CA往往也会被各种系统加入吊销名单。不过对于蓄意产生的CA证书么，就难说的很了。附上一个用于检测CNNIC证书的网站，&lt;a href=&#34;https://www.enum.cn/&#34;&gt;https://www.enum.cn/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;另一个风险证书则是comodo，早些时候，这个公司被黑客入侵，导致黑客给自己签发了一堆证书。虽然目前这些证书已经被吊销，不过这种安全公司让人一点信任感都没有。最好果断删除。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hack comix for windows use gbk as filename code</title>
      <link>http://shell909090.org/blog/archives/1727/</link>
      <pubDate>Mon, 14 Mar 2011 09:44:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1727/</guid>
      <description>&lt;p&gt;Comix is a python application to view comic. it use pygtk as GUI library, so technically, it can be used under windows. But unfortunately, it has code problem under windows. OK, 2 fix it, open src/filechooser.py:214.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gbkpath = paths\[0\].decode(&#39;utf-8&#39;).encode(&#39;gbk&#39;)
self.\_window.file\_handler.open\_file(gbkpath)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;done.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux下使用windows共享打印机打印</title>
      <link>http://shell909090.org/blog/archives/1676/</link>
      <pubDate>Wed, 12 Jan 2011 16:42:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1676/</guid>
      <description>&lt;p&gt;废话不说，上干货，六牙四皂小姐，猫咪退散。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.openprinting.org/printer/HP/HP-LaserJet_1010&#34;&gt;http://www.openprinting.org/printer/HP/HP-LaserJet_1010&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是我的机器型号和驱动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aptitude install cups foomatic-filters smbclient hpijs hplip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问&lt;a href=&#34;http://localhost:631/&#34;&gt;http://localhost:631/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;添加你的设备，并测试。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux虚拟化简介</title>
      <link>http://shell909090.org/blog/archives/1670/</link>
      <pubDate>Thu, 06 Jan 2011 10:14:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1670/</guid>
      <description>&lt;p&gt;又是科普文，行家免入。&lt;/p&gt;

&lt;p&gt;关于虚拟机的一些比较充分的讲解，可以看这里（&lt;a href=&#34;http://zh.wikipedia.org/zh-cn/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%AF%94%E8%BE%83&#34;&gt;http://zh.wikipedia.org/zh-cn/虚拟机比较&lt;/a&gt;）。下文是对linux下希望实现虚拟化和被虚拟化的情况提出一些简洁的说明。&lt;/p&gt;

&lt;p&gt;1.windows下虚拟出linux。&lt;/p&gt;

&lt;p&gt;不在意版权的人可以装个vmware 6.0以上，在意版权的装virtualbox开源版。字符界面通常分配128M内存，512M交换分区。图形界面512M内存，1024M交换分区。硬盘大小视各个发行会有所不同。对于多数工作用的系统，建议使用debian stable安装后升级到testing，稳定好用，最主要是简洁。128M内存512M交换8G的磁盘，足够系统安装和大部分的开发/运行。&lt;/p&gt;

&lt;p&gt;2.linux下虚拟windows。&lt;/p&gt;

&lt;p&gt;啥都别说，装virtualbox吧。破解vmware是很蛋疼的一件事情，装ESX就更蛋疼了。建议，XP512M内存以上，要稳定使用至少1G。倒是页面文件，只要512M就差不多了。硬盘至少准备16G以上，否则安装程序加运行数据，十有八九会空间不足。&lt;/p&gt;

&lt;p&gt;3.linux下虚拟linux。&lt;/p&gt;

&lt;p&gt;主要可用方案分为四类，系统虚拟化，半虚拟化，全虚拟化，硬件虚拟化，分别介绍。&lt;/p&gt;

&lt;p&gt;4.linux下虚拟一些比较怪的东西。&lt;/p&gt;

&lt;p&gt;这是职业玩家了，例如minix，或者freenas。改天写写后者，挺不错的一个创意。&lt;/p&gt;

&lt;p&gt;1.全虚拟化&lt;/p&gt;

&lt;p&gt;vmware是这种技术的代表。全虚拟化的特征是可以运行完全不同的系统，例如linux下运行windows。virtualbox是开源中做全虚拟化做的比较好的一款软件。当然，即使是全虚拟化，也必须是同一类CPU，例如32位虚拟64位CPU就不给力了。要虚拟不同的CPU，是CPU虚拟化，例如bochs和pearpc。速度大约是真机器的几十分之一，除了调试程序外没别的用途。&lt;/p&gt;

&lt;p&gt;全虚拟化比较适合玩玩其他系统，其他可以选用的方案有，vmware，virtualbox，virtual pc，qemu。&lt;/p&gt;

&lt;p&gt;2.半虚拟化&lt;/p&gt;

&lt;p&gt;Xen是这种技术的代表。通过修改的真机内核和客户机内核来支持虚拟化。优点是效率比全虚拟化高，缺点是客户机必须是可以修改内核的，这将windows排除在外。但是从理论上，可以在linux的xen上运行freebsd系统，两者都是开放内核源码的系统。&lt;/p&gt;

&lt;p&gt;半虚拟化技术一般被拿来做VPS比较多，基本没有其他可选用的方案。&lt;/p&gt;

&lt;p&gt;3.系统虚拟化&lt;/p&gt;

&lt;p&gt;OpenVZ是这种技术的代表。这种技术通过系统内核级别的代码修改来支持虚拟化。优点是效率比半虚拟化更高，缺点是客户机和服务器必须是同一个内核。因此真机和客户机都必须是linux（或者其他相同系统，例如freebsd），但是可以是不同发行（例如真机debian客户机centos），而且客户机不能自由加载内核模块。&lt;/p&gt;

&lt;p&gt;系统虚拟化也被用来做VPS，但是这种VPS有强烈的超卖可能，因此不推荐使用。反倒是在同一个公司内，因为某些原因需要将多个程序部署在多台设备上，每台设备所需的资源又不多的时候，比较适合用。其他可选用的方案有jails，vserver，virtuozzo。&lt;/p&gt;

&lt;p&gt;4.硬件虚拟化&lt;/p&gt;

&lt;p&gt;kvm是这种技术的代表。当然，vmware workstation，virtualbox等也可以支持这种技术。这种技术是未来虚拟化的大趋势。&lt;/p&gt;

&lt;p&gt;硬件虚拟化，是使用CPU和其他硬件的特殊设计，辅助虚拟化的进行。通过硬件虚拟化，虚拟机的执行效率往往可以达到和半虚拟化相似甚至超过的地步，而不需要客户系统的特殊配合。从设计理论上说，完整的硬件虚拟化应当可以在客户机上再执行全套的硬件虚拟化，如VM/370。但是目前Intel和AMD的家用CPU系列只支持在真机上创建一系列虚拟机实例，这些虚拟机的内部是不支持硬件虚拟化的。&lt;/p&gt;

&lt;p&gt;硬件虚拟化可以用在VPS/机器切分/新系统尝试等各种环境中，其他备选的方案有，vmware workstation，virtualbox，virtual pc，qemu。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>QQ和360之争</title>
      <link>http://shell909090.org/blog/archives/1609/</link>
      <pubDate>Mon, 08 Nov 2010 21:55:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/1609/</guid>
      <description>&lt;p&gt;两个流氓狗咬狗，老子一个都不用了。老子是Linux用户。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>论同时的双系统－－准虚拟对双系统的进一步扩充</title>
      <link>http://shell909090.org/blog/archives/49/</link>
      <pubDate>Mon, 12 Jan 2009 01:04:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/49/</guid>
      <description>&lt;p&gt;熟悉贝壳的人都知道，贝壳是个linux爱用者，不过因为工作关系，经常要使用windows。贝壳在自己的笔记本上使用了linux/windows混合双系统，并通过共用磁盘的方式共享数据，解决这个问题。但是长期的使用表明，这种解决方案存在几个巨大的瑕疵。首先是系统切换时间常，因此长期在一个系统中工作，而很少触及另外一个系统。其次是稳定性差，windows下一旦崩溃，进入linux后就需要检测数据盘，80G的数据慢慢扫描，感觉晕到死。那么是否有一种方案，能够同时使用两个工作级系统（注意，不是实验级，贝壳成功的在windows下的vmware里跑了一个oracle，这个可以说是实验级的典范。然而工作级系统的要求和实验级完全不同）。&lt;/p&gt;

&lt;p&gt;从系统发展史的角度来说，我们可以预见，将来的系统将是脱离硬件的。首要的原因就是和硬件不相匹配的各个层级的计算能力需求。现在系统发展有两个极端，一个是虚拟机，试图将一个硬件整体分离，运行多个系统。另一个是高性能集群，试图将多个硬件合并，运行一个系统。从根本上说，这是因为高性价比的硬件集中在了一个性能区间，而实际的性能需求却是完全分离的，因此我们才会出现如此两类完全背离的需求。而现在有大量宝贵的人力浪费在了系统和硬件结合，系统稳定性问题上，这无疑是对将来发展的一个巨大瓶颈。虽然无法预知将来的技术发展会以何种方式解决这个问题，然而可以预见的是，解决硬件和性能的背离将是人类计算机发展史上一个重要的里程碑，解决这个问题的人必定会在计算机历史上留下重重的一笔。&lt;/p&gt;

&lt;p&gt;同时，更进一步，贝壳揣测，将来的解决方案将是系统硬件调度/驱动和系统软件管理分离。一个软系统拥有一个用户表和一个硬件表，硬件表上写他可能有10个键盘，两个显示器，或者一堆其他设备。系统借助某个可信方案，管理了一系列虚拟抽象设备和真实设备形成的映射。作为系统层以上的软件，我们只要关心如何操作这个虚拟设备即可。而实际上，我们可以通过管理参数和对应关系实现各种需要。例如我们可以将多个机器的硬件管理核心加入一个系统，形成集群。或者我们可以在一个机器的硬件管理核心上加入多个系统，形成虚拟机。这个基本是分布系统的观点。如此一来，系统层软件就无法得知也无需得知自己是在到底运行在什么环境下。只是这个系统设计方案对高性能要求的子系统（主要是显卡）相当不利。&lt;/p&gt;

&lt;p&gt;从揣测回到现实，为了实现一个工作级系统（幸好，还不是工业级），我们需要为系统制定一些评判标准，以判别各个方案的优劣。我们首先能想到的评判标准就是速度，一个慢吞吞的系统解决方案是没有任何实用价值的。当然，这个速度是有差异的，可能是linux快一些，windows慢一些，或者相反。我们假定实际的需要是windows快一些，因为linux可以通过定制进行加速。&lt;/p&gt;

&lt;p&gt;我们的第二个评判标准就是稳定性，经常会崩溃的系统不比慢吞吞的系统好到哪里去，甚至会更加让人讨厌。虽然工作级系统并没有工业级那样高的要求，然而高负荷稳定，宕机平均频率低于3天/次还是要保证的。而后我们还希望两个系统可以做到数据互通，即两个系统间的数据尽可能的共享，至少要做到文件和邮件的共享。最后，我们希望解决方案简单易用，便于实施和维护。&lt;/p&gt;

&lt;p&gt;而后，我们列出了一个原始方案，和以下几个改进解决方案，并给出优劣评价，谨供大家参考借鉴。同时我们在其中还补充了一些无法实际解决问题的虚拟化解决方案，并且说明无法使用的原因，供适合的人自行选用。&lt;/p&gt;

&lt;p&gt;原始方案，windows+linux+数据分区。此种方案是最中规中矩的，性能最高的方案。具有对硬件最好的支持，最容易的维护。如果需要运行游戏（尤其是魔兽，WOW），这也是唯一可行的工作级方案。稳定性评价属于尚可，主要由于ntfs在linux的稳定性并不好，ext3在windows需要使用非官方驱动，和某些（就是avast）驱动不兼容。数据互通比较方便，通过数据分区可以轻松的共享文件和邮件。&lt;/p&gt;

&lt;p&gt;windows虚拟方案，vmware+虚拟分区。这种方案是改进方案中唯一可以跑游戏的，因为虚拟机随时可以关上。性能上满足windows快 linux慢的要求，虚拟系统显示性能良好，也可以通过文件共享部分的解决数据共享问题（文件共享方便，邮件共享困难）。稳定性很好，基本没有什么不稳定的问题出现，操作和维护都不困难。然而之所以一开始这种方案就被排除在外，主要是因为这种方案无法让linux驱动实体硬件，无法通过机器启动。这样也许对一些跑起来玩玩的人或者是内核工程师/测试员比较有用，然而如果要在linux里面进行大量工作，编译程序，运行服务，这种方案就力有未逮。因此这个方案可以说是一个实验级方案，而非工作级。&lt;/p&gt;

&lt;p&gt;windows虚拟方案，vmware+实体硬盘。速度一般，windows快linux慢，基本和上面一个方案一样，唯一的区别就是linux也可以被实际驱动。然而这也成了整个方案的最大败笔，因为linux的驱动灵活性不如windows，因此无法经受这种系统切换的动作。举例来说，真实的机器上，硬盘是sata的，作为sda识别和使用。而虚拟机上则是IDE的，被识别成了hda。于是启动环境一变，就需要修改大量配置来调和这个问题。又例如，在真实机器上，X使用fglrx驱动，而虚拟机下面要用mesa。如果我在/etc/xorg.conf中不指定驱动，那么真实机器的驱动也会变成 mesa，导致性能下降。如果指定驱动，又会导致虚拟机内X无法运行。诸如此类的问题林林总总，需要大量细节修正，因此维护复杂，稳定性差，不建议正式使用。在贝壳机器上更严重的，出现了虚拟机内和虚拟机外争抢数据分区的状况，这种情况下数据分区实质是被当做盘阵用了。使用非专用的磁盘作为底层共享存储，并在上面运行ext3系统，这是及其危险和愚蠢的。&lt;/p&gt;

&lt;p&gt;linux虚拟方案，xen。速度超快，但是上来就在贝壳的机器上暴出几个问题，因而没有继续测试。首先是安装xen后x无法启动，出现fglrx驱动无法加载的状况。其次是xen要求使用虚拟盘启动，可贝壳经常需要跑到windows下面打游戏。因此在简单测试后被剔除出局。感觉这种方案的最大问题在于配置管理太过复杂，debian下面已经很轻松了，只需要安装对应内核，使用工具建立虚拟机，但是依旧感觉麻烦到一塌糊涂。相信这种方案在专业级服务器领域应当有不俗表现。&lt;/p&gt;

&lt;p&gt;linux虚拟方案，openvz。这种方案压根就不适合贝壳的状况，因为这个虚拟方案要求宿主和客户必须是同一CPU同一系统（不要求同一linux发行）。主要用于希望将一个主机切分成多个独立的同构主机，以达到分离管理的目的（例如业务服务器和数据库服务器分离）。需要做大型网络管理/虚拟主机业务的人可能会对这个虚拟方案感兴趣。&lt;/p&gt;

&lt;p&gt;linux虚拟方案，vmware。速度一般，linux快windows慢，视频效果不错。vmware毕竟是商业公司，视频驱动挺齐全的。但是内核驱动的编译麻烦到死，首先是要求编译器版本和主内核编译器版本一致，于是贝壳去搞了个gcc-4.1，然后连接了上去。下面又是内核头定义出现版本差异，搞到现在还没有搞定。谁能搞的定的给个参考，最好是debian上的解决方案。&lt;/p&gt;

&lt;p&gt;linux虚拟方案，kvm。这个是贝壳目前使用的方案，基本比较理想。速度很快，和xen基本差不多，显示速度不如vmware（理论上说装好显卡驱动应该会好点，不过贝壳找不到CLDC5446的XP驱动，那是Win32和Win95时代的显卡）。linux快windows慢，但是还在可忍受范围内。稳定性很好，只要测试通过，运行中到目前为止没有死机（当然很多参数是加了之后开机即死机）。数据可以通过samba互通，邮件也同样可以互通。然而使用samba无疑复杂很多，而且性能并不太好。只是从稳定性上说，让linux自己去驱动ext3总比半吊子的windows驱动更好，同时也不会出现争抢的问题。易用性上还算可以，无论是内核编译还是系统使用都不太难，最大的麻烦就是网络配置。根据贝壳的测试，在真实机器上superpi运行100W 位需要45秒，虚拟机内需要54-60秒，尤其在换用kvm-72.2后反而更慢了（54下降到60，折合真实机器83.3％下降到75％）。&lt;/p&gt;

&lt;p&gt;总体来说，贝壳更倾向于使用全开源的准-全虚拟解决方案kvm，主要因为他简便易行，对系统影响小，不改变现有系统。同时性能高，稳定性好。主要需要解决显卡效率问题。如果以上问题无法彻底解决，贝壳打算换用linux下的vmware，想办法搞定他的内核模块。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一些关于盗版、黑屏、开源的事情</title>
      <link>http://shell909090.org/blog/archives/44/</link>
      <pubDate>Mon, 03 Nov 2008 14:04:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/44/</guid>
      <description>&lt;p&gt;大家都知道，微软搞黑屏了。贝壳暂时就这个事情不发表评论，而是先说一些其他的事情，然后大家再回过头来看这个事情怎么说。&lt;/p&gt;

&lt;p&gt;首先是软件的版权区别。开源软件，自由软件，免费软件，共享软件，收费软件，盗版软件，这些我们经常说的名词究竟有什么意义，有什么相同和区别？&lt;/p&gt;

&lt;p&gt;首先，大家要了解一个事情，上述对软件的不同称呼，其实是不可并列称呼的。免费收费，是指软件的付费方式，开源闭源，是指源码的公布方式，正版盗版，是指是否侵犯版权。这些其实是不同的事情，只是很多事情有前后的因果关系，因此大家容易混为一谈。一般我们可以将软件分为是否收费，是否开源，什么版权三种分类方式。分清其中的区别有益于阅读下面的内容。&lt;/p&gt;

&lt;p&gt;开源软件是指源代码开放的软件系统。多数情况下，开源意味着免费和自由，但是也存在收费的例子。例如许多大型系统（好像有些UNIX就是，但现在具体什么情况，贝壳没有用过，也没有看过软件协议），其源码对使用者开放（注意，开源并不代表对所有人开放，只要使用者有权获得源码即可。当然，如果范围缩小到使用者中的特定群体有权，则不算开源，例如微软的不可泄露协议），但是属于绝对的收费系统。大家很容易理解这里面的原因，既然源码已经开放，那么多数人都可以轻易写出类似的系统，在这种情况下还要坚持收费就愚蠢了。除非源码庞大，需要相当的水准和时间来理解，这样才能保持收费。当然，更多的情况是开源免费，收取专家服务费。&lt;/p&gt;

&lt;p&gt;这里中间还要插入一句法律问题（怎么感觉写成法律普及文了），目标软件的作用是给予使用，源码的作用是表达思想，这是公认一致的原则。换言之，如果你发布的是病毒目标，则是违法。如果你发布了病毒源码（当然，要排除恶意发布），则是研究之用，不属于违法。当年DeCSS的审判之所以被判定无罪，即是基于上述原则。&lt;/p&gt;

&lt;p&gt;免费软件是指授权方式是不要钱的。现在免费软件的很大一个来源是来自开源社区，然而并非只有开源了才免费，共享软件和试用软件就是其中的两个典型。共享软件的作者允许你可以免费的使用它的软件，但是并不开源。试用软件的作者允许你在一定期限内免费使用软件或其中的一定功能（其实试用软件的完整授权也不一定要用钱，写个邮件把作者夸一顿或者给他做些事情，例如翻译软件，一样可以获得授权）。这些软件虽然免费，但是往往会因为有其他的原因而选择闭源。例如微软的Process Explorer，就是属于共享软件的典型。这个软件原属于sysinternels的作品，后被微软收购。如果是开源软件，搞不好要和微软打官司，也不可能被收购。而Winrar则是试用软件的典型，大家都听说过Winrar推动检查中国大型公司内使用非授权产品的例子吧。这个例子难就难在取证这个软件产品超过了使用期限，因为大多数人可以通过重装来避免提示。&lt;/p&gt;

&lt;p&gt;自由软件是一个非常复杂的概念，要理解需要了解一些西方法律精神。自由软件现在在中国基本被视同为开源软件，其实两者是完全不一样的两个东西。自由指的是你拥有软件的选择权，包括是否使用，是否修改，是否散发，是否改善，具体可以参考这个文档（&lt;a href=&#34;http://www.gnu.org/philosophy/free-sw.zh-cn.html&#34;&gt;http://www.gnu.org/philosophy/free-sw.zh-cn.html&lt;/a&gt; ）。为了保证以上权力，开源是必须的，然而开源并不代表你拥有以上权力。我们在上文提到过，是否开源和什么版权是两个事情。开源软件可以选择收费版权，也可以选择非收费版权，但是禁止你修改，再散发软件。这些都不属于自由软件的范畴。&lt;/p&gt;

&lt;p&gt;自由软件的起因来自于上世纪70年代出现在美国的自由潮。受到自由潮的影响，当时很多软件大牛都是黑客精神（不是现在这堆脚本小子讲的黑客）的拥护者。他们认为人类学习和使用软件的自由不言自明，他们拒绝为他们的帐户加上密钥，并且以破解软件系统为乐。他们所写的程序也是免费分发。很难想象，在上世纪70 年代的时候，很多现在具备极大影响力的项目在当时只是几个人看不爽而随手做的一些小程序。很多自由项目直到现在还无人可以超越，发挥着重要作用。&lt;/p&gt;

&lt;p&gt;自由软件运动是天赋人权观念在知识领域的延伸，目的是推动知识的扩散。因为知识产品都有一个学习的概念，新手需要不断的观摩和学习成熟的系统才能成长。然而如果允许其他人无限制的学习，那么新知识的发明就无法给创造者带来利益，从而导致没有人愿意发明创新。因此专利法规定专利的存在，给予了发明人一定时期的权限，使其可以从中获利。而同时规定了专利期限，使得新手可以学习。（贝壳注：现在的很多专利期限动辄50年70年，实在是太长了一点，10年到20 年的期限应当是合适的）而自由软件在创造伊始就放弃了自身的专利权，给予了其他人学习和改进的权利，因此被认为是软件业的第一推动力。尤其是近些年，在 GNU的推动下，出现很多很优秀的软件产品。当然，其中大部分是和普通人无缘的。例如flex分析器，emacs编辑器。&lt;/p&gt;

&lt;p&gt;盗版软件这个词很不好界定，因为有两种界定线。一种是收费软件不付费使用，一种是违反软件使用授权。从范围上说，后者比前者更广泛，因为付费主要是取得软件使用授权，不付费一定违反了授权原则。而违反授权则不一定是不付费，也可能是试用软件超期（违反试用授权中期限限定），未授权可以修改而进行修改（这个尤其多出现在使用源码库的时候），违反最终用户协定（在共享软件中常见）。一般我们说的时候都指前者，但实质上，后者也属于软件权违法的例子。我们不妨用违法软件来称呼后者，而用盗版软件来称呼前者。&lt;/p&gt;

&lt;p&gt;盗版软件是否是自由软件思想影响下的产物？绝对不是。我们上文说了，自由软件运动的主要目的是普及软件知识，那么破解软件成果如何普及软件知识呢？无法自圆其说。也有人说这个是打击收费软件，以扩大开源软件的影响力。这就要讲到西方的毒树毒果理论，这个理论认为，非法手段（毒树），无论为了什么目地，其产生的结果一定是恶意的（毒果）。开源软件有着自己的适用范围，不需要也不可以通过这种方式强行介入收费领域。再者说，如果没有收费软件来为大型项目提供资金，没有大型公司来消化软件人才，那么程序员的将来也就无法保证，更谈不上进一步普及和推进计算机研究发展了。&lt;/p&gt;

&lt;p&gt;盗版软件只是一些不喜欢付费或者根本不拿版权当回事情的人，为了自己的利益编造出来的一堆谎言。例如微软的这次黑屏，很多人都在抵制，都在骂微软。我们可以想象一下，如果微软的产品出来的时候就带着黑屏措施呢？他们照用不误，最多就是搞一下破解。Winrar也带了保护措施，用的人照样一堆堆，破解照样满天飞。微软只和合法购买者订立了合同，保证不会侵犯他们的权益。非法使用者从根本上就没有依据来保障，你的系统即使上了Windows就当场机器爆炸，也无法控告人家。&lt;/p&gt;

&lt;p&gt;其实本质上说，贝壳也是违法软件使用者。在这个社会里面，看清每个软件的版权，然后一点不差的照做是完全不可能的，可能的只有知道行为违法后想法弥补。使用盗版windows则是因为贝壳根本是linux用户，但是同事全是清一色的windows，沟通不方便而被迫使用。既然我不是主动高兴买的，就上个盗版得了，被发现最多回到linux下结束（中国的法律对个人侵权行为只纠正行为）。使用盗版windows，我们人人知道违法，但中国的法律基于告诉乃论，就是所谓的民不告，官不纠。自己知道怎么回事，回去闷声发大财就算了，明明是违法者，还跳出来义正词严的指责受害者，做人不能太CNN。&lt;/p&gt;

&lt;p&gt;就如同我在MSN名字中写的那样。我虽然不赞成你黑屏，但是我捍卫你黑屏的权力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一些使用firefox的技巧</title>
      <link>http://shell909090.org/blog/archives/435/</link>
      <pubDate>Mon, 10 Mar 2008 13:33:31 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/435/</guid>
      <description>&lt;p&gt;在linux下和windows下共享同样配置/插件。这个很简单，上面的blog中有篇文章说到thnunderbird在双系统下共享同样邮件的问题，firefox也一样解决。能用linux的人不会查不出配置目录位置吧。&lt;/p&gt;

&lt;p&gt;节约内存技巧。&lt;/p&gt;

&lt;p&gt;firefox虽然号称小巧，然而很多时候我们发现他的内存消耗也非常惊人。在贝壳的机器上，有的时候会高达150M，基本等于普通编辑器/播放器的10倍。事实上，不是firefox浪费内存，而是默认的内存配置是针对&amp;rdquo;机器上只开firefox&amp;rdquo;设计的。如果你机器内存小，或者需要同时开其他程序，最好自己配置一下firefox。&lt;/p&gt;

&lt;p&gt;首先就是fasterfox，关闭其中的&amp;rdquo;增强预读&amp;rdquo;，这东西很消耗内存。然后是内存缓存，调整到32M吧。一般一个网页上所有文件差不多1M-2M，32M够把20个网页的所有内容缓存起来，再多就不大正常了。根据贝壳自己的猜测，渲染动作应当是动态进行的，否则内存根本顶不住长文本的渲染。这样在浏览的时候，从后台抓取内容，动态渲染的速度就非常重要，因此强烈推荐不要小于8M。否则连5个页面的内容都不在内存中命中，还玩个P阿～&lt;/p&gt;

&lt;p&gt;还有渲染中的&amp;rdquo;启用快速返回&amp;rdquo;，将内存中的保留页面数调整小，贝壳用的是3。当然，这个只适用于firefox1.5。&lt;/p&gt;

&lt;p&gt;其次是session manager，将&amp;rdquo;撤销关闭&amp;rdquo;尽量减小。反正贝壳减小到了1个窗口3个页面。这些页面在关闭后还是继续消耗系统的内存，因此越小越好。当然，小到多少是要看你的具体需要了。&lt;/p&gt;

&lt;p&gt;最后，少用插件，少启用插件，除非你真的需要。长期不需要的就禁用，或者干脆卸载。&lt;/p&gt;

&lt;p&gt;内存回收技巧。&lt;/p&gt;

&lt;p&gt;很简单，觉得不够了，关了再开。反正有session manager，正在浏览的网页根本不会有影响。&lt;/p&gt;

&lt;p&gt;同时打开大批网页技巧。&lt;/p&gt;

&lt;p&gt;最好使用Tree Style Tab，这样方便。另外，如果需要打开一个页面的所有连接，可以这样做。先察看页面信息，选择&amp;rdquo;链接&amp;rdquo;-&amp;gt;&amp;ldquo;全部选择&amp;rdquo;-&amp;gt;&amp;ldquo;复制&amp;rdquo;，然后开一个文本文件，把内容粘贴进去。可以看到内容其实是一堆的页面链接。当然，如果页面内有js做的链接指向，可以试试用Convert javascript or onclick to normal links这个greasemonkey脚本转换成目标链接。然后，把这个文本文件改名成htm，打开。通常情况下应该是一堆无法点击的文字，不过你可以用Linkify ting来把文字转换成一堆链接。然后……一个个点过去吧。&lt;/p&gt;

&lt;p&gt;上面是使用greasemonkey解决的方法，当然，也有更简单的方法。你可以安装flashgot，然后新增一个下载管理器，名字叫做firefox。路径就指向firefox的执行文件路径，参数不用动。平时用你喜欢的管理器，需要打开全部链接的时候，更改为firefox，然后&amp;rdquo;使用flashgot下载全部链接&amp;rdquo;。当然，缺点是对付不了js脚本，除非你加载Convert javascript or onclick to normal。&lt;/p&gt;

&lt;p&gt;不过鉴于内存状态考虑，建议不要同时打开大量页面。维持在10-20个上下最好。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Process Explorer的潜在内存泄漏</title>
      <link>http://shell909090.org/blog/archives/426/</link>
      <pubDate>Thu, 31 Jan 2008 19:21:06 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/426/</guid>
      <description>&lt;p&gt;贝壳最近碰到一个郁闷到死的问题。机器经常出现硬盘狂转，系统响应延迟。系统弹出一个错误，然后死机。贝壳开始猜测是硬盘驱动问题，升级驱动N次，无效。然后再猜测是ext2fs的问题(贝壳用这个驱动挂载linux下面的盘的)，看来看去，不是。最后，贝壳确定了，这是内存泄漏了～～～&lt;br /&gt;
   
问题是，这时候可没人跳出来推荐喝什么口服液的。贝壳系统中永远挂着一个procexp，看内存状态的。这东西是sysinternals的产品，后来被微软收购了。功能强大，很多系统调试，杀马都需要用到。于是贝壳就用这个工具看哪个程序的内存泄漏，可是看来看去看不到。准确说，是没等贝壳看到，系统就先死透了。最后贝壳多次尝试，发现了一个死机的规律。当mysql开启的时候，procexp就会随时发生异常死机。这是一个重要的提示，要么mysql内存泄漏了，要么procexp内存泄漏了。究竟是哪个呢？贝壳用了同属于sysinternals开发的pstools系列工具，仔细检查了异常发生时候的内存状态，确定，Process
Explorer存在内存泄漏的风险！&lt;br /&gt;
   
看来sysinternals被微软收购后，旗下的工具也出现了微软的一贯特色。以下是一次内存泄漏后，终止mysql服务后抓下来的内存状态输出。如果不终止mysql，不等我抓系统就挂了。&lt;br /&gt;
Process memory detail for HOME-B2326348D0:&lt;/p&gt;

&lt;p&gt;Name                Pid      VM      WS    Priv Priv Pk   Faults   NonP
Page&lt;br /&gt;
Idle                  0       0      28       0       0        0     
0    0&lt;br /&gt;
System                4     800      52       0       0    10120     
0    0&lt;br /&gt;
smss                772    3748      48     172    1648      223     
0    5&lt;br /&gt;
csrss               828   68132    1464    2304    3768    13748      6 
144&lt;br /&gt;
winlogon            856   61528     580    8536    8684     5143    
39   96&lt;br /&gt;
services            900   37724     804    2256    2404     2740     
7   65&lt;br /&gt;
lsass               912   44848     352    2684    2860     7332     
7   80&lt;br /&gt;
svchost            1060   36904     200    1500    1544     1028     
3   68&lt;br /&gt;
svchost            1136   39256     456    1984    2004     1437    
13   72&lt;br /&gt;
svchost            1216  118756    2564   19236   28112    24221     93 
197&lt;br /&gt;
svchost            1292   31728     192    1472    1512     1123     
4   55&lt;br /&gt;
aswUpdSv           1536   18748      52     652     652      557     
2   31&lt;br /&gt;
ashServ            1592  120428    6704   16628   41168  1076043      8 
128&lt;br /&gt;
explorer           1884  119644    1908   19128   20552  4364782     16 
177&lt;br /&gt;
spoolsv             288   50072     224    3564    3828     1502     
5   85&lt;br /&gt;
TSVNCache           544   48008     700    6968    7068    21580     
4   67&lt;br /&gt;
mobmeter            620   41116     588    4940    5044    14266     
3   63&lt;br /&gt;
procexp             628  605756   15532  549068  549068  4776417      8 
109&lt;br /&gt;
ashDisp             636   54468     928    6992    7016    28399     
5   80&lt;br /&gt;
ctfmon              664   39064     380    4816    4840    15588     
4   66&lt;br /&gt;
googletalk          720   76420    2852    8540    9036   428030     13 
108&lt;br /&gt;
mdm                 832   30008     440    1088    1100      860     
3   49&lt;br /&gt;
svchost            1244   40704     208    2640    2708     1896     
3   73&lt;br /&gt;
svnserve           1264   16612     124     904     920      652     
3   29&lt;br /&gt;
svchost             232   37936     536    1592    1636     1330     
4   70&lt;br /&gt;
alg                 600   35664     200    1312    1352     1018     
5   69&lt;br /&gt;
TTPlayer           3208   65672    3688   10920   13924   169533     
8   86&lt;br /&gt;
thunderbird        3240  109016    2272   28832   31344    64167     14 
112&lt;br /&gt;
conime             3284   42564     404    5184    5184    17612     
3   68&lt;br /&gt;
firefox            1944  270920   11108  118720  132648  1233696     14 
135&lt;br /&gt;
flashget           2836  108756   11248   19472   29636   117115     30 
146&lt;br /&gt;
pyintau            2080   45004     172    4720    4788     1848     
3   62&lt;br /&gt;
wuauclt            1068   67012     396    6580    6600     2167      7 
115&lt;br /&gt;
cmd                3540   32764     920    3308    3372    15075     
2   60&lt;br /&gt;
pslist             3048   32124    3108    2440    2956    10890     
2   49&lt;br /&gt;
   
我们可以看到，procexp这个进程的虚拟内存空间只有60M，工作集更只有15M，可私有内存高达549M！贝壳的机器只有768M内存，不死机还等啥？&lt;br /&gt;
   
贝壳试验了mysql5.0.45，mysql5.0.51a，mysql5.1.22，procexp11.01，procexp11.04。确定在贝壳的本本上全都会造成上述问题。但是同样的环境在家里的2G内存机器上模拟的时候，全都不出现上述问题。从测试角度讲，这个属于和环境相关的隐性危险，严重级别是重。&lt;/p&gt;

&lt;div&gt;

&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>弄死MSN的共享文件夹</title>
      <link>http://shell909090.org/blog/archives/425/</link>
      <pubDate>Sat, 26 Jan 2008 22:43:47 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/425/</guid>
      <description>&lt;p&gt;MSN8的共享文件夹功能根本就是一个废物功能，速度慢，不习惯，而且用处不大。最恶心的是，没有卸载选项不说，手工卸载后一开MSN一重起还会回来。NND，看我怎么弄死他。MSN虽然是微软自己的产品，但是也需要遵守微软的API行为。改变资源管理器的行为是用COM组件注入到exlporer中实现的，没有使用驱动层的东西。那么我们就设法阻断DLL文件的注入加载。&lt;/p&gt;

&lt;p&gt;首先，regsvr32 /u是不行的。因为MSN一启动又会注册上，除非你不用MSN。删除文件也不行，因为会再生成一个。那么，我放着文件不动，把内容清空，然后再删除NTFS权限怎么样呢？即使是微软的产品，也不会强制说我的更改无效，然后自己胡来一套吧。&lt;/p&gt;

&lt;p&gt;首先，关闭所有MSN有关软件，在运行中输入cmd开一个命令行窗口。然后，用process explorer(现在这东西也是微软的产品)终止explorer进程(系统自带那个应该也行，不过我没有测试过)。这步顺序非常重要，因为我们要先阻断COM组件的加载，否则无法对文件实行更改。所以我们要先打开一个CMD，然后再关闭explorer。否则一旦关闭explorer，开CMD就难了。而没有CMD，要去删除文件就要多费一些手续了。&lt;/p&gt;

&lt;p&gt;我们现在在CMD中切换到MSN所在目录，删除fsshext.8.1.0178.00.dll啥的文件。这个文件名会根据你安装的版本而变化。而后启动explorer(在CMD里面敲explorer就好)，这个时候COM组件已经没有加载了。于是我们建立一个文本文件，改名叫fsshext.8.1.0178.00.dll，放到MSN的目录里面，再删除所有人的访问权限。删除的方法是文件上右击，点属性，安全，高级，取消&amp;rdquo;从父目录继承权限&amp;rdquo;的勾选，然后点删除。如果看不到安全选项卡，检查以下项目。工具，文件夹选项，察看，使用简单文件共享(推荐)，取消他的勾选。微软的东西，最好表随便勾。&lt;/p&gt;

&lt;p&gt;根据我的测试，这时候你随便重起电脑，MSN的组件说加载不上就加载不上。同理也可以应用到3721之类的流氓组件上，只要抢先建立了同名的文件，并且阻断了权限，这些组件就会无法使用。如果你进一步做了分离权限(日常不使用管理员账户)，即使安装程序作者知道这种方法都无法应对。如果可以的话，就说明微软存在漏洞了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux和windows共享邮件</title>
      <link>http://shell909090.org/blog/archives/417/</link>
      <pubDate>Sun, 04 Nov 2007 22:59:14 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/417/</guid>
      <description>&lt;p&gt;总算能发正常的文章了，前面发出来的老是不会断行。庆祝一下。&lt;/p&gt;

&lt;p&gt;很多人像贝壳一样使用双系统，Linux加windows。贝壳的Linux用的是Debian，最近其中的xfce4出现一些问题。使用的时候老是死机，这日子没法过了。所以贝壳就稍微下了点功夫，先弄个好用的windows凑合一下。&lt;/p&gt;

&lt;p&gt;windows下最难办的恐怕就是邮件了，到不是说不能收。只是windows下一个邮件状况，Linux下一个。未免讨厌了点。就算有导入导出可以转换，你想转换多少次呢？&lt;/p&gt;

&lt;p&gt;下面贝壳就说一种方法来对付这种状况。&lt;/p&gt;

&lt;p&gt;首先你的系统盘应当是ntfs，否则这方法不能用。然后在windows下安装ext2ifs来读取linux的home目录，假定是d:\username.mozilla-thunderbird。windows下安装类似版本的thunderbird，然后看看你的C:\Document and Setting\username\Application Data\Thunderbird下面，是否有一个profile.ini？有就对了。删除这个目录(我没说错)，然后去下一个叫做junction的软件，微软出的。这个软件可以将ntfs的某个目录映射到一个目标上去，对这个目录的访问就等同于对这个目标的访问，就好像linux下面的符号链接一样。下面知道我要做什么了么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;junction &amp;quot;C:\Document and Setting\username\Application Data\Thunderbird&amp;quot; d:\username\.mozilla-thunderbird
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动thunderbird，他首先会检查你系统中插件的版本可用性。然后你的Linux下邮件就可以用了。&lt;/p&gt;

&lt;p&gt;简单吧？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>windows service的C&#43;&#43;封装实现</title>
      <link>http://shell909090.org/blog/archives/338/</link>
      <pubDate>Wed, 20 Dec 2006 20:09:10 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/338/</guid>
      <description>&lt;p&gt;windows系统服务入口的封装类，service是基类，service_manager是管理类。支持UNICODE，可以多服务封装在一个程序里面，过程当然都是自动的。拥有自动防错系统，在服务异常退出的时候会去关闭服务，而不是开着服务直接没了进程。写一个类，继承service，然后在哪里出一个实例，就可以了。service中有很多虚函数，可以重载了监听对应事件(我应该写的比较明白吧)。get_service_name，返回UNICODE的字符串指针，定义服务名称。注意是纯虚函数，必须实现。get_dependence，也是返回UNICODE的字符指针。指明这个服务依赖什么服务。get_service_type返回服务类型，其实也就是是否可以交互。get_contral_accepts，支持的信号(例如是否可以暂停)，默认可以暂停。on_start开始时候调用的函数，下同。&lt;/p&gt;

&lt;p&gt;使用方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include
#include &amp;quot;service.h&amp;quot;

class test_service : public service{
public:
    virtual LPTSTRget_service_name ();
    virtual DWORD on_start (DWORD argc, LPTSTR * argv);
    virtual DWORD on_stop ();
    virtual DWORD on_shutdown ();
};

LPTSTR test_service::get_service_name ()
{
    return _T (&amp;quot;test_service&amp;quot;);
}

DWORD test_service::on_start (DWORD argc, LPTSTR * argv)
{
    return service::on_start (argc, argv);
}

DWORD test_service::on_stop ()
{
    return service::on_stop ();
}

DWORD test_service::on_shutdown ()
{
    return service::on_shutdown ();
}

int _tmain (int argc, _TCHAR * argv[])
{
    test_service ts;
    if (argc == 1)
        service_manager::start ();
    else if (!_tcscmp (argv[1], _T (&amp;quot;install&amp;quot;)))
        service_manager::install_services (NULL, false);
    else if (!_tcscmp (argv[1], _T (&amp;quot;remove&amp;quot;)))
        service_manager::remove_services (NULL);
    return 0;
}

------------service.h-------------------
#include
using namespace std;
#include
#pragma comment(lib, &amp;quot;psapi&amp;quot;)

typedef basic_string &amp;lt; TCHAR &amp;gt; tstring;

#ifndef _SERVICE_H_
#define _SERVICE_H_

class service {
public:
    service ();
    ~service ();
    virtual LPTSTRget_service_name () = 0;
    virtual LPTSTRget_dependence ();
    virtual DWORD get_service_type ();
    virtual DWORD get_contral_accepts ();
    virtual DWORD on_start (DWORD argc, LPTSTR * argv);
    virtual DWORD on_stop ();
    virtual DWORD on_interrogate ();
    virtual DWORD on_pause ();
    virtual DWORD on_continue ();
    virtual DWORD on_shutdown ();
    voidpre_start (SERVICE_STATUS_HANDLE hServiceStatus,
               DWORD argc, LPTSTR * argv);
    BOOL SetServiceStatus (DWORD dwState);
protected:
    SERVICE_STATUS_HANDLE hServiceStatus;
    SERVICE_STATUS ServiceStatus;
};

class service_manager {
public:
    service_manager ();
    ~service_manager ();
    DWORDregister_service (service * s);
    DWORDunregister_service (service * s);
    LPSERVICE_TABLE_ENTRYget_service_entries ();
    service *get_service (LPCTSTR lpName);
    static service_manager *get_service_manager();
    static intinstall_services (LPCTSTR lpServiceName, bool
                    autostart);
    static intremove_services (LPCTSTR lpServiceName);
    static intstart();
    static void WINAPIservice_start (DWORD argc, LPTSTR * argv);
    static DWORD WINAPIctrl_handler (DWORD dwControl, DWORD
                     dwEventType,
                     LPVOID lpEventData, LPVOID lpContext);
    static TCHAR *service_status_name[];
protected:
    static service_manager *this_for_static;
    vector &amp;lt; service * &amp;gt;service_list;
};

#endif //_SERVICE_H_

----------------------------------------

------------service.cpp-----------------

// service.cpp : 定义控制台应用程序的入口点。
//
#include &amp;quot;stdafx.h&amp;quot;

#define PRINTERROR(x) _tprintf (_T (&amp;quot;%s failed, errorcode 0x%0.8X\n&amp;quot;),(x), GetLastError ())

service_manager *service_manager::this_for_static = NULL;
TCHAR *service_manager::service_status_name[] = {
    _T (&amp;quot;SERVICE_UNKNOWN&amp;quot;),
    _T (&amp;quot;SERVICE_STOPPED&amp;quot;),
    _T (&amp;quot;SERVICE_START_PENDING&amp;quot;),
    _T (&amp;quot;SERVICE_STOP_PENDING&amp;quot;),
    _T (&amp;quot;SERVICE_RUNNING&amp;quot;),
    _T (&amp;quot;SERVICE_CONTINUE_PENDING&amp;quot;),
    _T (&amp;quot;SERVICE_PAUSE_PENDING&amp;quot;),
    _T (&amp;quot;SERVICE_PAUSED&amp;quot;)
};

service::service ()
{
    if (service_manager::get_service_manager () == NULL)
        new service_manager ();
    service_manager::get_service_manager ()-&amp;gt;register_service
        (this);
}

service::~service ()
{
    if (service_manager::get_service_manager () == NULL)
        return;
    service_manager::get_service_manager ()-&amp;gt;unregister_service(this);
}

LPTSTR service::get_dependence ()
{
    return NULL;
}

DWORD service::get_service_type ()
{
    return 0;
}

DWORD service::get_contral_accepts ()
{
    return SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_SHUTDOWN |
        SERVICE_ACCEPT_STOP;
}

DWORD service::on_start (DWORD argc, LPTSTR * argv)
{
    return SERVICE_RUNNING;
}

DWORD service::on_stop ()
{
    return SERVICE_STOPPED;
}

DWORD service::on_interrogate ()
{
    return SERVICE_RUNNING;
}

DWORD service::on_pause ()
{
    return SERVICE_PAUSED;
}

DWORD service::on_continue ()
{
    return SERVICE_RUNNING;
}

DWORD service::on_shutdown ()
{
    return SERVICE_STOPPED;
}

void service::pre_start (SERVICE_STATUS_HANDLE hServiceStatus,
             DWORD argc, LPTSTR * argv)
{
    this-&amp;gt;hServiceStatus = hServiceStatus;
    ServiceStatus.dwServiceType = SERVICE_WIN32;
    ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    ServiceStatus.dwControlsAccepted = 0;
    ServiceStatus.dwWin32ExitCode = 0;
    ServiceStatus.dwServiceSpecificExitCode = 0;
    ServiceStatus.dwCheckPoint = 0;
    ServiceStatus.dwWaitHint = 10000;
    SetServiceStatus (0);
    ServiceStatus.dwCurrentState = on_start (argc, argv);
    if (ServiceStatus.dwCurrentState == SERVICE_STOPPED)
        ServiceStatus.dwWin32ExitCode = ServiceStatus.dwCurrentState;
    ServiceStatus.dwCheckPoint = 0;
    ServiceStatus.dwWaitHint = 0;
    ServiceStatus.dwControlsAccepted = get_contral_accepts ();
    SetServiceStatus (0);
    return;
}

BOOL service::SetServiceStatus (DWORD dwState)
{
    TCHAR lpOutString[0x400];
    if (dwState != 0)
        ServiceStatus.dwCurrentState = dwState;
    if (ServiceStatus.dwCurrentState &amp;gt; 7)
        return 0;
    BOOL rslt =::SetServiceStatus (hServiceStatus, &amp;amp;ServiceStatus);
    if (rslt)
        _stprintf (lpOutString,
               _T (&amp;quot;%s set service status %s successed.\n&amp;quot;),
               get_service_name (),
               service_manager::service_status_name[ServiceStatus.
                                dwCurrentState]);
    else
        _stprintf (lpOutString,
               _T
               (&amp;quot;%s set service status %s failed, errorcode 0x%0.8X\n&amp;quot;),
               get_service_name (),
               service_manager::service_status_name[ServiceStatus.
                                dwCurrentState],
               GetLastError ());
    OutputDebugString ((LPCTSTR) lpOutString);
    return rslt;
}

service_manager::service_manager ()
{
    if (this_for_static != NULL)
        return;
    this_for_static = this;
}

service_manager::\~service_manager ()
{
    this_for_static = NULL;
}

DWORD service_manager::register_service (service * s)
{
    vector &amp;lt; service * &amp;gt;::iterator iter;
    iter = service_list.begin ();
    for (; iter != service_list.end (); iter++)
        if (*iter == s)
            return 1;
    service_list.push_back (s);
    return 0;
}

DWORD service_manager::unregister_service (service * s)
{
    vector &amp;lt; service * &amp;gt;::iterator iter;
    iter = service_list.begin ();
    for (; iter != service_list.end (); iter++)
        if (*iter == s) {
            service_list.erase (iter);
            return 0;
        }
    return -1;
}

LPSERVICE_TABLE_ENTRY service_manager::get_service_entries ()
{
    UINT i;
    LPSERVICE_TABLE_ENTRY lte = NULL;
    lte = new SERVICE_TABLE_ENTRY[service_list.size () + 1];
    for (i = 0; i &amp;lt; service_list.size (); i++) {
        lte[i].lpServiceName = service_list[i]-&amp;gt;get_service_name
            ();
        lte[i].lpServiceProc = (LPSERVICE_MAIN_FUNCTION) service_start;
    }
    lte[i].lpServiceName = NULL;
    lte[i].lpServiceProc = NULL;
    return lte;
}

service *service_manager::get_service (LPCTSTR lpName)
{
    for (UINT i = 0; i &amp;lt; service_list.size (); i++)
        if (!_tcscmp (service_list[i]-&amp;gt;get_service_name (), lpName))
            return service_list[i];
    return NULL;
}

int service_manager::install_services (LPCTSTR lpServiceName, bool
                       autostart)
{
    UINT i;
    int rslt = 0;
    DWORD service_type;
    TCHAR binary_path[0x400];
    SC_HANDLE hSCManager = NULL, hService = NULL;
    service *pservice;
    if (lpServiceName == NULL) {
        for (i = 0; i &amp;lt; this_for_static-&amp;gt;service_list.size (); i++)
            install_services (this_for_static-&amp;gt;service_list[i]-&amp;gt;
                      get_service_name (), autostart);
        return 0;
    }
    pservice = this_for_static-&amp;gt;get_service (lpServiceName);
    if (pservice == NULL) {
        _tprintf (_T (&amp;quot;get_service %s failed, don&#39;t have this service\n&amp;quot;),
              lpServiceName);
        return -1;
    }
    if (!GetModuleFileNameEx (GetCurrentProcess (), NULL, binary_path,
                  0x400)) {
        PRINTERROR (_T (&amp;quot;GetModuleFileNameEx&amp;quot;));
        return -1;
    }
    if (this_for_static-&amp;gt;service_list.size () &amp;lt; 2)
        service_type = SERVICE_WIN32_OWN_PROCESS;
    else
        service_type = SERVICE_WIN32_SHARE_PROCESS;
    __try {
        hSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (hSCManager == NULL) {
            rslt = -1;
            __leave;
        }
        hService = CreateService (hSCManager, lpServiceName, lpServiceName,
                      SC_MANAGER_ALL_ACCESS,
                      pservice-&amp;gt;
                      get_service_type () | service_type,
                      (autostart ? SERVICE_AUTO_START :
                       SERVICE_DEMAND_START),
                      SERVICE_ERROR_NORMAL, binary_path, NULL,
                      NULL, pservice-&amp;gt;get_dependence (), NULL,
                      NULL);
        if (hService == NULL) {
            rslt = -2;
            __leave;
        }
    }
    __finally {
        if (hService != NULL)
            CloseServiceHandle (hService);
        if (hSCManager != NULL)
            CloseServiceHandle (hSCManager);
        if (rslt == 0)
            _tprintf (_T (&amp;quot;install_services %s successed\n&amp;quot;), lpServiceName);
        if (rslt == -1)
            PRINTERROR (_T (&amp;quot;OpenSCManager&amp;quot;));
        if (rslt == -2)
            PRINTERROR (_T (&amp;quot;CreateService&amp;quot;));
    }
    return rslt;
}

int service_manager::remove_services (LPCTSTR lpServiceName)
{
    int rslt = 0;
    UINT i;
    SC_HANDLE hSCManager, hService;
    service *pservice;
    if (lpServiceName == NULL) {
        for (i = 0; i &amp;lt; this_for_static-&amp;gt;service_list.size (); i++)
            remove_services (this_for_static-&amp;gt;service_list[i]-&amp;gt;
                     get_service_name ());
        return 0;
    }
    pservice = this_for_static-&amp;gt;get_service (lpServiceName);
    if (pservice == NULL) {
        _tprintf (_T (&amp;quot;get_service failed, don&#39;t have this service\n&amp;quot;));
        return -1;
    }
    __try {
        hSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (hSCManager == NULL) {
            rslt = -1;
            __leave;
        }
        hService =
            OpenService (hSCManager, lpServiceName, SC_MANAGER_ALL_ACCESS);
        if (hService == NULL) {
            rslt = -2;
            __leave;
        }
        if (!DeleteService (hService)) {
            rslt = -3;
            __leave;
        }
    }
    __finally {
        if (hService != NULL)
            CloseServiceHandle (hService);
        if (hSCManager != NULL)
            CloseServiceHandle (hSCManager);
        if (rslt == 0)
            _tprintf (_T (&amp;quot;remove_services %s successed\n&amp;quot;), lpServiceName);
        if (rslt == -1)
            PRINTERROR (_T (&amp;quot;OpenSCManager&amp;quot;));
        if (rslt == -2)
            PRINTERROR (_T (&amp;quot;OpenService&amp;quot;));
        if (rslt == -3)
            PRINTERROR (_T (&amp;quot;DeleteService&amp;quot;));
    }
    return rslt;
}

int service_manager::start ()
{
    if (!StartServiceCtrlDispatcher
        (this_for_static-&amp;gt;get_service_entries ()))
        OutputDebugString (_T (&amp;quot;StartServiceCtrlDispatcher failed\n&amp;quot;));
    return 0;
}

void WINAPI service_manager::service_start (DWORD argc, LPTSTR *
                        argv)
{
    SERVICE_STATUS_HANDLE hServiceStatus;
    service *pservice = this_for_static-&amp;gt;get_service
        (argv[0]);
    if (pservice == NULL) {
        OutputDebugString (_T
                   (&amp;quot;get_service failed, don&#39;t have this service\n&amp;quot;));
        return;
    }
    hServiceStatus =
        RegisterServiceCtrlHandlerEx (argv[0], ctrl_handler, (LPVOID)
                          pservice);
    if (hServiceStatus == NULL) {
        OutputDebugString (_T (&amp;quot;RegisterServiceCtrlHandlerEx return NULL\n&amp;quot;));
        return;
    }
    __try {
        pservice-&amp;gt;pre_start (hServiceStatus, argc, argv);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pservice-&amp;gt;SetServiceStatus (SERVICE_STOPPED);
    }
    return;
}

DWORD WINAPI service_manager::ctrl_handler (DWORD dwControl,
                        DWORD dwEventType,
                        LPVOID lpEventData,
                        LPVOID lpContext)
{
    DWORD status;
    service *pservice = (service *) lpContext;
    SetLastError (NO_ERROR);
    __try {
        switch (dwControl) {
        case SERVICE_CONTROL_STOP:
            status = pservice-&amp;gt;on_stop ();
            break;
        case SERVICE_CONTROL_SHUTDOWN:
            status = pservice-&amp;gt;on_shutdown ();
            break;
        case SERVICE_CONTROL_PAUSE:
            status = pservice-&amp;gt;on_pause ();
            break;
        case SERVICE_CONTROL_INTERROGATE:
            status = pservice-&amp;gt;on_interrogate ();
            break;
        case SERVICE_CONTROL_CONTINUE:
            status = pservice-&amp;gt;on_continue ();
            break;
        default:
            return GetLastError ();
        }
        pservice-&amp;gt;SetServiceStatus (status);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pservice-&amp;gt;SetServiceStatus (SERVICE_STOPPED);
    }
    return GetLastError ();
}

service_manager *service_manager::get_service_manager ()
{
    return this_for_static;
}

----------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之所有list没有写成map是因为在某个服务处理过程中可能需要用到服务的名称。写成map就需要反向查询，也不是很方便。register_service中会查询这个服务是否已经注册过，注意不能用服务名对比的方法。这也是我才发现的一个问题，C++在基类的构造函数中的时候，虚函数指针是指向基类虚函数表的。在某个service子类构造的时候，其基类(service)构造函数会自动调用register_service方法注册自身。如果在register_service用取得服务名的方法，此时虚函数指针指向了基类的虚函数表。也就是说，我们会调用到一个纯虚函数入口，从而产生C++错误。所以必须手工来匹配指针，大家忍耐忍耐。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>